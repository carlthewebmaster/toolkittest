<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Database Access Support - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_dbapi" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="http://www.ncbi.nlm.nih.gov/core/jig/1.13.1/js/jig.min.js "></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents ▾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access Support</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_faq.html">29. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">30. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="ch_conn.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="ch_cgi.html">Next &gt;</a></div><div class="pdf-link"><a class="print-link" title="PDF version of this page" href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/ch_dbapi.pdf">PDF</a></div></div><div class="meta_content"><h1><span class="label">10</span><span class="title">Database Access Support</span></h1><p class="small">Last Update: April 2, 2015.</p></div><div class="body-content jig-ncbiinpagenav" data-jigconfig="allHeadingLevels: ['h2'],smoothScroll: false"><div class="sec"><h2><span class="title">Overview</span></h2><p>The overview for this chapter consists of the following topics:</p><ul><li><p>Introduction</p></li><li><p>Chapter Outline</p></li></ul><div class="sec"><h3><span class="title">Introduction</span></h3><p>This chapter covers the C++ Toolkit support for database access using:</p><ul><li><p>the <a href="ch_dbapi.html#ch_dbapi.SDBAPI_UserLayer_Reference">SDBAPI</a> database access library [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/simple/">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/simple/">src</a>];</p></li><li><p>the <a href="ch_dbapi.html#ch_dbapi.The_DBAPI_Library">DBAPI</a> database access library [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/">src</a>];</p></li><li><p>the <a href="ch_dbapi.html#ch_dbapi.Major_Features_of_th">BDB</a> wrapper [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/db/bdb/">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/db/bdb/">src</a>]; or</p></li><li><p>the <a href="ch_dbapi.html#ch_dbapi.The_SQLite_Wrapper">SQLite</a> wrapper [<a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/db/sqlite/">include</a> | <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/db/sqlite/">src</a>].</p></li></ul><p>DBAPI was the traditional database access library interface, but has been superseded by SDBAPI - the "simplified" interface. They have considerable overlap, but they are fully not compatible and each has at least one feature the other doesn't, so you must pick one. For example, DBAPI allows a choice of underlying drivers and access to the underlying data source while SDBAPI does not. On the other hand, SDBAPI supports bookmarking blobs while DBAPI doesn't. In the vast majority of cases SDBAPI will be both more than adequate and easier to use and maintain. Therefore, SDBAPI should be the first choice unless there's a compelling reason to use DBAPI.</p><p>The DBAPI library provides the underlying <a href="ch_dbapi.html#ch_dbapi.dbapi_user_layer">user-layer</a> and <a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">driver</a> API for the NCBI database connectivity project. The project's goal is to provide access to various relational database management systems (RDBMS) with a single uniform user interface. Consult the detailed documentation for details of the <a href="ch_dbapi.html#ch_dbapi.dbapi_drivers">supported DBAPI drivers</a>.</p><p>The "BDB wrapper" is part of the NCBI C++ Toolkit and serves as a high-level interface to the open source Berkeley DB library. The BDB wrapper is architecturally different from the DBAPI library and does not follow its design - rather, it is compatible with Berkeley DB v. 4.1 and higher. The primary purpose of the Berkeley DB library is to provide tools to work with flatfile, federated databases. Thus, the BDB wrapper is intended for use by software developers who need small-footprint, high-performance database capabilities with zero administration. The database in this case becomes tightly integrated with the application code. For more information about Berkeley DB, see the official <a href="http://www.oracle.com/us/products/database/berkeley-db/overview/index.html">documentation</a>.</p><p>The "SQLite wrapper" is part of the NCBI C++ Toolkit and serves as a high-level interface to the open source SQLite library. The SQLite wrapper is architecturally different from the DBAPI library and does not follow its design - rather, it is compatible with SQLite v. 3.6.14 and higher. The primary purpose of the SQLite library is to provide small, fast, and reliable in-process full-SQL database access. The SQLite wrapper provides convenient wrappers for SQLite-related objects and most commonly used functions. The wrapper requires SQLite 3.6.14 or higher with the asynchronous VFS extension and assumes that no SQLite calls are made except via the wrapper itself. For more information about SQLite, see the official <a href="http://sqlite.org/docs.html">documentation</a>.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Security">Security</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Preventing_SQL_Injection">Preventing SQL Injection</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Kerberos_with_DBAPI">Using Kerberos with DBAPI</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.SDBAPI__DBAPI_Feature_Compariso">SDBAPI / DBAPI Feature Comparison</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.SDBAPI_UserLayer_Reference">The SDBAPI Library</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">SDBAPI Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Includes_and_Linkage">Includes and Linkage</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Connections">Connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Executing_Basic_Queries">Executing Basic Queries</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Stored_Procedures_and_Parameter">Stored Procedures and Parameters</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Retrieving_Results">Retrieving Results</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Getting_a_Stored_Procedure_Retu">Getting a Stored Procedure Return Value</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.MetaData_Accessors">Meta-Data Accessors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Working_with_NULL">Working with NULL</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Transactions">Using Transactions</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Cursors">Using Cursors</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.The_DBAPI_Library">The DBAPI Library</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_user_layer">DBAPI User-Layer Reference</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_overview">DBAPI Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_hierarchy">Object Hierarchy</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_includes">Includes</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_objects">Objects</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_lifecycle">Object Life Cycle</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_variant">CVariant Type</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_choose_driver">Choosing the Driver</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_src_cnxns">Data Source and Connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_main_loop">Main Loop</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_io_params">Input and Output Parameters</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_stored_procs">Stored Procedures</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_cursors">Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_wwblobs">Working with BLOBs</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_blobs">Updating BLOBs Using Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_bulk_insert">Using Bulk Insert</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_diag">Diagnostic Messages</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_trace">Trace Output</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_driver_ref">DBAPI Driver Reference</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_overview">Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_arch">The driver architecture</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_errors">Error handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_context">Driver context and connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_mgr">Driver Manager</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_txt_img">Text and Image Data Handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_results">Results loop</a></p></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drivers">Supported DBAPI drivers</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS (TDS ver. 7.0)</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_ctlib">Sybase CTLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvrs_odbc">ODBC</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.mysql_driver">MySQL Driver</a></p></li></ul></li></ul></li><li><p><a href="ch_dbapi.html#ch_dbapi.Major_Features_of_th">The BDB Wrapper</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.The_SQLite_Wrapper">The SQLite Wrapper</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Database_loadbalanci">Database Load-Balancing (DBLB)</a></p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Getting_started">Setting up Load-Balancing of Database Servers</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Database_LoadBalancing_fr">Using Database Load-Balancing from C++</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Database_Access_via_Python_and">Load-Balanced Database Access via Python and Perl</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Advantages_of_using_">Advantages of using DBLB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.HOW_IT_WORKS_by_defa">How it works (by default)</a></p></li></ul></li></ul></div></div><div class="sec" id="ch_dbapi.Security"><h2><span class="title">Security</span></h2><div class="sec" id="ch_dbapi.Preventing_SQL_Injection"><h3><span class="title">Preventing SQL Injection</span></h3><p>This section is not intended to cover all the important aspects of security because a lot of good information on the topic is already published elsewhere. Please use other resources to find the security-related information needed for your work.</p><p>However, it's worth pointing out a couple of the most important ways to protect against SQL injection:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Never construct a SQL statement from user-supplied input if the same functionality can be achieved by passing the user input to stored procedures or parameterized SQL.</p></dd><dt>2</dt><dd><p class="no_top_margin">If constructing a SQL statement from user-supplied input cannot be avoided, then you MUST sanitize the user input.</p></dd></dl><p>The following sample programs illustrates how to protect against SQL injection for basic SQL statements using SDBAPI and DBAPI:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/sdbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/sdbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li></ul><p>See the <a href="ch_faq.html#ch_faq.Security">Security FAQ</a> for more information.</p></div><div class="sec" id="ch_dbapi.Using_Kerberos_with_DBAPI"><h3><span class="title">Using Kerberos with DBAPI</span></h3><p>Within NCBI, individual users (i.e. not service accounts) can use Kerberos with DBAPI, provided the following conditions are met:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">The database must allow them to connect using Kerberos. (Email <span class="oem_mark">dbhelp@ncbi.nlm.nih.gov</span> if you need help with this.)</p></dd><dt>2</dt><dd><p class="no_top_margin">DBAPI must be configured to enable Kerberos.</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin">Either the <span class="nctnt ncbi-var">NCBI_CONFIG__DBAPI__CAN_USE_KERBEROS</span> environment variable must be set to <span class="nctnt ncbi-monospace">true</span>; or</p></dd><dt>b</dt><dd><p class="no_top_margin">the <span class="nctnt ncbi-monospace">can_use_kerberos</span> entry in the <span class="nctnt ncbi-monospace">dbapi</span> section of the application configuration file must be set to <span class="nctnt ncbi-monospace">true</span>.</p></dd></dl></dd><dt>3</dt><dd><p class="no_top_margin">Their Kerberos ticket must not be expired.</p></dd><dt>4</dt><dd><p class="no_top_margin">They must pass an empty string for the user name.</p></dd></dl><p>This is also covered in the <a href="ch_libconfig.html#ch_libconfig.DBAPI">DBAPI section</a> of the Library Configuration chapter.</p></div></div><div class="sec" id="ch_dbapi.SDBAPI__DBAPI_Feature_Compariso"><h2><span class="title">SDBAPI / DBAPI Feature Comparison</span></h2><p>SDBAPI is mostly a wrapper over DBAPI, and as such it introduces some overhead - some of which is unavoidable. SDBAPI and DBAPI each have some features that aren't available in the other, but SDBAPI is usually more than sufficient for 95% of real-life tasks (and it makes them easier to code too). So, in most cases you should use SDBAPI.</p><p>The following features are only available in DBAPI:</p><ul><li><p>Choice of driver (e.g. CTLIB, ODBC, etc.).</p></li><li><p>Support for cursors.</p></li><li><p>Writing BLOBs to streams.</p></li></ul><p>The following features are only available in SDBAPI:</p><ul><li><p>Bookmarking BLOBs.</p></li></ul><p>The following table compares the implementation of various features in DBAPI and SDBAPI:</p><div class="table" id="ch_dbapi.T.nc_featuresdbapidbapisample_c"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Feature</th><th align="left" valign="top" rowspan="1" colspan="1">SDBAPI</th><th align="left" valign="top" rowspan="1" colspan="1">DBAPI</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">sample code</td><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/">src/sample/app/sdbapi</a></td><td align="left" valign="top" rowspan="1" colspan="1"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/">src/sample/app/dbapi</a></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">available drivers</td><td align="left" valign="top" rowspan="1" colspan="1">FTDS</td><td align="left" valign="top" rowspan="1" colspan="1">CTLIB, FTDS, MYSQL, ODBC</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">cursor support</td><td align="left" valign="top" rowspan="1" colspan="1">no</td><td align="left" valign="top" rowspan="1" colspan="1">yes</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">writing BLOBs to streams</td><td align="left" valign="top" rowspan="1" colspan="1">no</td><td align="left" valign="top" rowspan="1" colspan="1">yes</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">bookmarking BLOBs</td><td align="left" valign="top" rowspan="1" colspan="1">yes</td><td align="left" valign="top" rowspan="1" colspan="1">no</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">access to stored procedure parameters</td><td align="left" valign="top" rowspan="1" colspan="1">only by name</td><td align="left" valign="top" rowspan="1" colspan="1">by name or position (note: if possible, prefer using names over positions because using positions creates maintenance difficulties)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">makefile <span class="nctnt ncbi-monospace">REQUIRES</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">REQUIRES = dbapi FreeTDS</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace"># choose driver, e.g. FreeTDS, BerkeleyDB, or SQLITE3</span><br /><span class="nctnt ncbi-monospace">REQUIRES = dbapi FreeTDS</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">makefile <span class="nctnt ncbi-monospace">LIB</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">LIB = $(SDBAPI_LIB) xconnect xutil xncbi</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">LIB = ncbi_xdbapi_ftds $(FTDS_LIB) \</span><br /><span class="nctnt ncbi-monospace">      dbapi_util_blobstore$(STATIC) dbapi$(STATIC) dbapi_driver$(STATIC) \</span><br /><span class="nctnt ncbi-monospace">      $(XCONNEXT) xconnect $(COMPRESS_LIBS) xutil xncbi</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">makefile <span class="nctnt ncbi-monospace">LIBS</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">LIBS = $(SDBAPI_LIBS) $(NETWORK_LIBS) $(DL_LIBS) $(ORIG_LIBS)</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">LIBS = $(FTDS_LIBS) $(CMPRS_LIBS) $(NETWORK_LIBS) $(DL_LIBS) $(ORIG_LIBS)</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">includes</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">&lt;dbapi/simple/sdbapi.hpp&gt;</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">// "new" DBAPI</span><br /><span class="nctnt ncbi-code">#include &lt;dbapi/dbapi.hpp&gt;</span><br /><br /><span class="nctnt ncbi-code">// "old" DBAPI</span><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/dbapi_conn_factory.hpp&gt;  // CTrivialConnValidator</span><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/dbapi_svc_mapper.hpp&gt;    // DBLB_INSTALL_DEFAULT</span><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/drivers.hpp&gt;             // DBAPI_RegisterDriver_FTDS</span><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/exception.hpp&gt;           // CDB_UserHandler</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">to set up a connection</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">// Specify connection parameters.</span><br /><span class="nctnt ncbi-code">CSDB_ConnectionParam    db_params;</span><br /><span class="nctnt ncbi-code">db_params.Set(CSDB_ConnectionParam::eUsername, m_User);</span><br /><span class="nctnt ncbi-code">db_params.Set(CSDB_ConnectionParam::ePassword, m_Password);</span><br /><span class="nctnt ncbi-code">db_params.Set(CSDB_ConnectionParam::eService,  m_Service);</span><br /><span class="nctnt ncbi-code">db_params.Set(CSDB_ConnectionParam::eDatabase, m_DbName);</span><br /><br /><span class="nctnt ncbi-code">// Connect to the database.</span><br /><span class="nctnt ncbi-code">m_Db = CDatabase(db_params);</span><br /><span class="nctnt ncbi-code">m_Db.Connect();</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">// Use load balancing if available.</span><br /><span class="nctnt ncbi-code">DBLB_INSTALL_DEFAULT();</span><br /><br /><span class="nctnt ncbi-code">// Explicitly register a driver.</span><br /><span class="nctnt ncbi-code">DBAPI_RegisterDriver_FTDS();</span><br /><br /><span class="nctnt ncbi-code">CDriverManager&amp; dm(CDriverManager::GetInstance());</span><br /><br /><span class="nctnt ncbi-code">// Create a data source - the root object for all other</span><br /><span class="nctnt ncbi-code">// objects in the library.</span><br /><span class="nctnt ncbi-code">m_Ds = dm.CreateDs("ftds");</span><br /><br /><span class="nctnt ncbi-code">// Setup diagnostics.</span><br /><span class="nctnt ncbi-code">m_Logstream.open(m_LogFileName.c_str());</span><br /><span class="nctnt ncbi-code">m_Ds-&gt;SetLogStream(&amp;m_Logstream);</span><br /><br /><span class="nctnt ncbi-code">// Add a message handler for 'context-wide' error messages (not bound</span><br /><span class="nctnt ncbi-code">// to any particular connection); let DBAPI own it.</span><br /><span class="nctnt ncbi-code">I_DriverContext* drv_context = m_Ds-&gt;GetDriverContext();</span><br /><span class="nctnt ncbi-code">drv_context-&gt;PushCntxMsgHandler(</span><br /><span class="nctnt ncbi-code">    new CErrHandler("General", &amp;m_Logstream),</span><br /><span class="nctnt ncbi-code">    eTakeOwnership);</span><br /><br /><span class="nctnt ncbi-code">// Add a 'per-connection' message handler to the stack of default</span><br /><span class="nctnt ncbi-code">// handlers which are inherited by all newly created connections;</span><br /><span class="nctnt ncbi-code">// let DBAPI own it.</span><br /><span class="nctnt ncbi-code">drv_context-&gt;PushDefConnMsgHandler(</span><br /><span class="nctnt ncbi-code">    new CErrHandler("Connection", &amp;m_Logstream),</span><br /><span class="nctnt ncbi-code">    eTakeOwnership);</span><br /><br /><span class="nctnt ncbi-code">// Configure this context.</span><br /><span class="nctnt ncbi-code">drv_context-&gt;SetLoginTimeout(10);</span><br /><span class="nctnt ncbi-code">// default query timeout for client/server comm for all connections</span><br /><span class="nctnt ncbi-code">drv_context-&gt;SetTimeout(15);</span><br /><br /><span class="nctnt ncbi-code">// Create connection.</span><br /><span class="nctnt ncbi-code">m_Conn = m_Ds-&gt;CreateConnection();</span><br /><span class="nctnt ncbi-code">if (m_Conn == NULL) {</span><br /><span class="nctnt ncbi-code">    ERR_POST_X(1, Fatal &lt;&lt; "Could not create connection.");</span><br /><span class="nctnt ncbi-code">}</span><br /><br /><span class="nctnt ncbi-code">// Validate connection.  When using load balancing, this will interpret</span><br /><span class="nctnt ncbi-code">// the "server" name as a service, then use the load balancer to find</span><br /><span class="nctnt ncbi-code">// servers, then try in succession until a successful login to the</span><br /><span class="nctnt ncbi-code">// given database is successful.</span><br /><span class="nctnt ncbi-code">CTrivialConnValidator val(m_DbName);</span><br /><span class="nctnt ncbi-code">m_Conn-&gt;ConnectValidated(val, m_User, m_Password, m_Service, m_DbName);</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">to execute a stored procedure</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">CQuery query = m_Db.NewQuery();</span><br /><span class="nctnt ncbi-code">query.SetParameter("@max_id", 5);</span><br /><span class="nctnt ncbi-code">query.SetParameter("@max_fl", 5.1f);</span><br /><span class="nctnt ncbi-code">query.SetParameter("@num_rows", 0, eSDB_Int4, eSP_InOut);</span><br /><span class="nctnt ncbi-code">query.ExecuteSP(proc_name);</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">ICallableStatement *cstmt = conn-&gt;PrepareCall("ProcName");</span><br /><span class="nctnt ncbi-code">Uint1 byte = 1;</span><br /><span class="nctnt ncbi-code">cstmt-&gt;SetParam(CVariant("test"), "@test_input");</span><br /><span class="nctnt ncbi-code">cstmt-&gt;SetParam(CVariant::TinyInt(&amp;byte), "@byte");</span><br /><span class="nctnt ncbi-code">cstmt-&gt;SetOutputParam(CVariant(eDB_Int), "@result");</span><br /><span class="nctnt ncbi-code">cstmt-&gt;Execute();</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">to retrieve results</td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">// Print the results.</span><br /><span class="nctnt ncbi-code">//</span><br /><span class="nctnt ncbi-code">// NOTE: For database APIs, array-like indexes are 1-based, not 0-based!</span><br /><span class="nctnt ncbi-code">//</span><br /><span class="nctnt ncbi-code">NcbiCout &lt;&lt; "int_val    fl_val" &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">ITERATE(CQuery, row, query.SingleSet()) {</span><br /><span class="nctnt ncbi-code">    NcbiCout</span><br /><span class="nctnt ncbi-code">        &lt;&lt; row[1].AsInt4() &lt;&lt; "    "</span><br /><span class="nctnt ncbi-code">        &lt;&lt; row[2].AsFloat() &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">}</span><br /><br /><span class="nctnt ncbi-code">// Confirm having read all results.</span><br /><span class="nctnt ncbi-code">query.VerifyDone();</span><br /><br /><span class="nctnt ncbi-code">// Print the number of result rows.</span><br /><span class="nctnt ncbi-code">NcbiCout</span><br /><span class="nctnt ncbi-code">    &lt;&lt; "Number of rows: "</span><br /><span class="nctnt ncbi-code">    &lt;&lt; query.GetParameter("@num_rows").AsInt4() &lt;&lt; NcbiEndl;</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">// Retrieve and display the data.</span><br /><span class="nctnt ncbi-code">while (stmt-&gt;HasMoreResults()) {</span><br /><span class="nctnt ncbi-code">    // Use an auto_ptr to manage resultset lifetime.</span><br /><span class="nctnt ncbi-code">    // NOTE: Use it with caution. When the wrapped parent object</span><br /><span class="nctnt ncbi-code">    // goes out of scope, all child objects are destroyed</span><br /><span class="nctnt ncbi-code">    // (which isn't an issue for this demo but could be for</span><br /><span class="nctnt ncbi-code">    // other applications).</span><br /><span class="nctnt ncbi-code">    auto_ptr&lt;IResultSet&gt; rs(stmt-&gt;GetResultSet());</span><br /><br /><span class="nctnt ncbi-code">    // Sometimes the results have no rows - and that's ok.</span><br /><span class="nctnt ncbi-code">    if ( ! stmt-&gt;HasRows() ) {</span><br /><span class="nctnt ncbi-code">        LOG_POST_X(1, Info &lt;&lt; "No rows.");</span><br /><span class="nctnt ncbi-code">        continue;</span><br /><span class="nctnt ncbi-code">    }</span><br /><br /><span class="nctnt ncbi-code">    switch (rs-&gt;GetResultType()) {</span><br /><br /><span class="nctnt ncbi-code">    case eDB_StatusResult:</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; "\nStatus results:" &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        while (rs-&gt;Next()) {</span><br /><span class="nctnt ncbi-code">            NcbiCout &lt;&lt; "    Status: " &lt;&lt; rs-&gt;GetVariant(1).GetInt4()</span><br /><span class="nctnt ncbi-code">                &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        }</span><br /><span class="nctnt ncbi-code">        break;</span><br /><br /><span class="nctnt ncbi-code">    case eDB_ParamResult:</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; "\nParameter results:" &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        while (rs-&gt;Next()) {</span><br /><span class="nctnt ncbi-code">            NcbiCout &lt;&lt; "    Parameter: "</span><br /><span class="nctnt ncbi-code">                &lt;&lt; rs-&gt;GetVariant(1).GetInt4() &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        }</span><br /><span class="nctnt ncbi-code">        break;</span><br /><br /><span class="nctnt ncbi-code">    case eDB_RowResult: {</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; "\nRow results:" &lt;&lt; NcbiEndl;</span><br /><br /><span class="nctnt ncbi-code">        const IResultSetMetaData* rsMeta = rs-&gt;GetMetaData();</span><br /><br /><span class="nctnt ncbi-code">        // Print column headers.</span><br /><span class="nctnt ncbi-code">        for (unsigned i = 1; i &lt;= rsMeta-&gt;GetTotalColumns(); ++i) {</span><br /><span class="nctnt ncbi-code">            NcbiCout &lt;&lt; "    " &lt;&lt; rsMeta-&gt;GetName(i);</span><br /><span class="nctnt ncbi-code">        }</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        for (unsigned i = 1; i &lt;= rsMeta-&gt;GetTotalColumns(); ++i) {</span><br /><span class="nctnt ncbi-code">            NcbiCout &lt;&lt; "    " &lt;&lt; string(rsMeta-&gt;GetName(i).size(), '=');</span><br /><span class="nctnt ncbi-code">        }</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; NcbiEndl;</span><br /><br /><span class="nctnt ncbi-code">        while (rs-&gt;Next()) {</span><br /><span class="nctnt ncbi-code">            // Print a row of data.</span><br /><span class="nctnt ncbi-code">            for (unsigned i = 1; i &lt;= rsMeta-&gt;GetTotalColumns(); ++i) {</span><br /><span class="nctnt ncbi-code">                NcbiCout &lt;&lt; "    " &lt;&lt; rs-&gt;GetVariant(i).GetString();</span><br /><span class="nctnt ncbi-code">            }</span><br /><span class="nctnt ncbi-code">            NcbiCout &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        }</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; "    ---------------" &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        NcbiCout &lt;&lt; "    Row count: " &lt;&lt; stmt-&gt;GetRowCount()</span><br /><span class="nctnt ncbi-code">            &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">        break;</span><br /><span class="nctnt ncbi-code">    }</span><br /><br /><span class="nctnt ncbi-code">    // These types aren't used in this demo, but might be in</span><br /><span class="nctnt ncbi-code">    // your code.</span><br /><span class="nctnt ncbi-code">    case eDB_ComputeResult:</span><br /><span class="nctnt ncbi-code">    case eDB_CursorResult:</span><br /><span class="nctnt ncbi-code">        LOG_POST_X(1, Warning &lt;&lt; "Unhandled results type:"</span><br /><span class="nctnt ncbi-code">            &lt;&lt; rs-&gt;GetResultType());</span><br /><span class="nctnt ncbi-code">        break;</span><br /><br /><span class="nctnt ncbi-code">    // Any other type means this code is out-of-date.</span><br /><span class="nctnt ncbi-code">    default:</span><br /><span class="nctnt ncbi-code">        ERR_POST_X(1, Critical &lt;&lt; "Unexpected results type:"</span><br /><span class="nctnt ncbi-code">            &lt;&lt; rs-&gt;GetResultType());</span><br /><span class="nctnt ncbi-code">    }</span><br /><span class="nctnt ncbi-code">}</span><br /><span class="nctnt ncbi-code">// The stored procedure will return a status.</span><br /><span class="nctnt ncbi-code">NcbiCout &lt;&lt; "\nStored procedure returned status: "</span><br /><span class="nctnt ncbi-code">    &lt;&lt; cstmt-&gt;GetReturnStatus() &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">string msgs = m_Ds-&gt;GetErrorInfo();</span><br /><span class="nctnt ncbi-code">if ( ! msgs.empty() ) {</span><br /><span class="nctnt ncbi-code">    NcbiCout &lt;&lt; "    Errors:" &lt;&lt; NcbiEndl;</span><br /><span class="nctnt ncbi-code">    NcbiCout &lt;&lt; "        " &lt;&lt; msgs &lt;&lt; NcbiEndl;</span></td></tr></tbody></table></div></div></div><div class="sec" id="ch_dbapi.SDBAPI_UserLayer_Reference"><h2><span class="title">The SDBAPI Library</span></h2><div class="sec" id="ch_dbapi.Simple_Database_Access_via_C"><h3><span class="title">SDBAPI Overview</span></h3><p>The following snippet is a simple example of executing static SQL using the NCBI simplified database API (SDBAPI):</p><pre><span class="nctnt-pre ncbi-code">// Specify connection parameters.<br />CSDB_ConnectionParam    db_params;<br />db_params.Set(CSDB_ConnectionParam::eUsername, m_User);<br />db_params.Set(CSDB_ConnectionParam::ePassword, m_Password);<br />db_params.Set(CSDB_ConnectionParam::eService,  m_Service);<br />db_params.Set(CSDB_ConnectionParam::eDatabase, m_DbName);<br /><br />// Connect to the database.<br />CDatabase  db(db_params);<br />db.Connect();<br /><br />// Execute a query.<br />CQuery query = db.NewQuery("select title from Journal");<br />query.Execute();<br />ITERATE(CQuery, qit, query) {<br />    NcbiCout &lt;&lt; qit["title"].AsString() &lt;&lt; NcbiEndl; <br />}</span></pre><p><span class="nctnt highlight">Note:</span> Load balancing is performed automatically and transparently with SDBAPI - there's no need to call <span class="nctnt ncbi-func">DBLB_INSTALL_DEFAULT()</span>.</p><p>See the SDBAPI sample programs for more example code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/sdbapi/</a></p></li></ul><p>The following sections cover specific aspects of SDBAPI:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Includes_and_Linkage">Includes and Linkage</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Connections">Connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Executing_Basic_Queries">Executing Basic Queries</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Stored_Procedures_and_Parameter">Stored Procedures and Parameters</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Retrieving_Results">Retrieving Results</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Getting_a_Stored_Procedure_Retu">Getting a Stored Procedure Return Value</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.MetaData_Accessors">Meta-Data Accessors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Working_with_NULL">Working with NULL</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Transactions">Using Transactions</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Cursors">Using Cursors</a></p></li></ul></div><div class="sec" id="ch_dbapi.Includes_and_Linkage"><h3><span class="title">Includes and Linkage</span></h3><p>SDBAPI requires only one header:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/simple/sdbapi.hpp&gt;</span></pre><p>For proper linkage, merge the following into your LIB and LIBS lines:</p><pre>LIB  = $(SDBAPI_LIB) xconnect xutil xncbi<br />LIBS = $(SDBAPI_LIBS) $(NETWORK_LIBS) $(DL_LIBS) $(ORIG_LIBS)</pre></div><div class="sec" id="ch_dbapi.Connections"><h3><span class="title">Connections</span></h3><p>To establish a database connection, first specify the connection parameters, then create the database object using those parameters, then call the <span class="nctnt ncbi-func">Connect()</span> method, for example:</p><pre><span class="nctnt-pre ncbi-code">// Specify connection parameters.<br />CSDB_ConnectionParam    db_params;<br />db_params.Set(CSDB_ConnectionParam::eUsername, m_User);<br />db_params.Set(CSDB_ConnectionParam::ePassword, m_Password);<br />db_params.Set(CSDB_ConnectionParam::eService,  m_Service);<br />db_params.Set(CSDB_ConnectionParam::eDatabase, m_DbName);<br /><br />// Connect to the database.<br />m_Db = CDatabase(db_params);<br />m_Db.Connect();</span></pre><p>Additional parameters are available for connection pooling, timeouts, etc. Please see the <span class="nctnt ncbi-class">CSDB_ConnectionParam</span> <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSDB__ConnectionParam.html">class reference</a> for the up-to-date list.</p><p>After making the connection, it is recommended to set the connection session parameters, for example:</p><pre><span class="nctnt-pre ncbi-code">string sql("SET ANSI_NULLS ON\n"<br />           "SET ANSI_PADDING ON\n"<br />           "SET ANSI_WARNINGS ON\n"<br />           "SET ARITHABORT ON\n"<br />           "SET CONCAT_NULL_YIELDS_NULL ON\n"<br />           "SET QUOTED_IDENTIFIER ON\n"<br />           "SET NUMERIC_ROUNDABORT OFF");<br />CQuery query = m_Db.NewQuery(sql);<br />query.Execute();</span></pre><p>It may also be appropriate to set, <span class="nctnt ncbi-monospace">TEXTSIZE</span>, depending on your project.</p></div><div class="sec" id="ch_dbapi.Executing_Basic_Queries"><h3><span class="title">Executing Basic Queries</span></h3><p>Once a <a href="ch_dbapi.html#ch_dbapi.Connections">connection</a> is established, executing a basic query can be as simple as:</p><pre><span class="nctnt-pre ncbi-code">CQuery query = m_Db.NewQuery("your SQL statement goes here");<br />query.Execute();</span></pre><p><span class="nctnt highlight">Note:</span> There are security factors to be considered when executing queries. See the <a href="ch_dbapi.html#ch_dbapi.Security">security section</a>, and use the following guidelines when deciding which method to use:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">If stored procuedures can be used, then use them. This increases both security and performance. Plus, this practice could facilitate testing and documentation.</p></dd><dt>2</dt><dd><p class="no_top_margin">Otherwise, if the SQL statement does not depend on dynamic values, then use static SQL.</p></dd><dt>3</dt><dd><p class="no_top_margin">Otherwise, if parameterized SQL can be used, then use it.</p></dd><dt>4</dt><dd><p class="no_top_margin">Otherwise, as a last resort, use dynamic SQL. If user-supplied data is used to construct the statement, then you <b>MUST</b> sanitize the user-supplied data. Even if the data does not come from an outside user, it's still a good idea to sanitize all dynamic data unless there's a compelling reason not to, in which case that fact should be prominently documented in comments adjacent to the dynamic SQL creation code. See the <a href="ch_faq.html#ch_faq.Security">Security FAQ</a> for more information.</p></dd></dl></div><div class="sec" id="ch_dbapi.Stored_Procedures_and_Parameter"><h3><span class="title">Stored Procedures and Parameters</span></h3><p>The following settings should be made before executing a store procedure:</p><div class="table" id="ch_dbapi.T.nc_ansi_nullsonansi_paddingon"><div class="table-scroll"><table><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ANSI_NULLS</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ANSI_PADDING</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ANSI_WARNINGS</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ARITHABORT</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">CONCAT_NULL_YIELDS_NULL</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">QUOTED_IDENTIFIER</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">ON</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">NUMERIC_ROUNDABORT</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-monospace">OFF</span></td></tr></tbody></table></div></div><p>It may also be appropriate to set, <span class="nctnt ncbi-monospace">TEXTSIZE</span>, depending on your project.</p><p>Note that <span class="nctnt ncbi-var">ANSI_NULLS</span> and <span class="nctnt ncbi-var">QUOTED_IDENTIFIER</span> must be set when the stored procedure is created because they can't be changed at run-time. The other settings can be changed at run-time but typically they're not, so it's efficient to set them when the <a href="ch_dbapi.html#ch_dbapi.Connections">connection</a> is created.</p><p>For input parameters, simply pass the name and value to <span class="nctnt ncbi-func">SetParameter()</span>; for input/output parameters, also pass the database field type and the value <span class="nctnt ncbi-var">eSP_InOut</span>; for <span class="nctnt ncbi-monospace">NULL</span> parameters call <span class="nctnt ncbi-func">SetNullParameter()</span>. For example:</p><pre><span class="nctnt-pre ncbi-code">// input only<br />query.SetParameter("@id", 123);<br />query.SetNullParameter("@create_time", eSDB_DateTime);<br /><br />// input/output<br />query.SetParameter("@tolower", "aBcD", eSDB_String, eSP_InOut); <br />query.SetNullParameter("@result", eSDB_Int, eSP_InOut);</span></pre><p>The stored procedure is invoked by calling <span class="nctnt ncbi-func">ExecuteSP()</span>:</p><pre><span class="nctnt-pre ncbi-code">CQuery query = m_Db.NewQuery();<br />query.SetParameter("@max_id", 5);<br />query.ExecuteSP(proc_name);</span></pre></div><div class="sec" id="ch_dbapi.Retrieving_Results"><h3><span class="title">Retrieving Results</span></h3><p>It's best to reference columns by name, unless there's some compelling reason not to, because referencing columns by index is less maintanable. <span class="nctnt highlight">Note:</span> For the Toolkit database APIs, array-like indexes are 1-based, not 0-based. In other words, <span class="nctnt ncbi-func">operator[]()</span> starts at one for rows and columns.</p><p>For simple queries or stored procedures that return a single result set:</p><pre><span class="nctnt-pre ncbi-code">query.ExecuteSP(sproc_name);<br />ITERATE(CQuery, qit, query.SingleSet()) {<br />    NcbiCout &lt;&lt; qit["release_id"].AsInt4() &lt;&lt; NcbiEndl;<br />    // or, if there's a reason not to use column names<br />    NcbiCout &lt;&lt; qit[1].AsInt4() &lt;&lt; NcbiEndl;<br />}</span></pre><p>For stored procedures that return multiple result sets, SDBAPI supports two behavioral modes: either merging all result sets into one - chosen by calling <span class="nctnt ncbi-code">query.SingleSet()</span> - or returning them separately - chosen by calling <span class="nctnt ncbi-code">query.MultiSet()</span>. If neither <span class="nctnt ncbi-func">SingleSet()</span> nor <span class="nctnt ncbi-func">MultiSet()</span> is called, then SDBAPI chooses a default mode. The default was formerly MultiSet mode, but it has been switched to SingleSet mode with the release stable components 15.</p><p>Retrieving multiple result sets in SingleSet mode is accomplished exactly as if there was only one result set, as shown above. To retrieve multiple result sets in MultiSet mode, use <span class="nctnt ncbi-code">query.HasMoreResultSets()</span>:</p><pre><span class="nctnt-pre ncbi-code">while (query.HasMoreResultSets()) {<br />    ITERATE(CQuery, qit, query) {<br />        // do something with the current result set row<br />    }<br />}</span></pre><p>It is possible to verify that all data rows have been read, by using <span class="nctnt ncbi-func">VerifyDone()</span>:</p><pre><span class="nctnt-pre ncbi-code">ITERATE(CQuery, qit, query) {<br />    // do something with the current result set row<br />}<br />query.VerifyDone(); // throws if any rows remain unread</span></pre><p>Similarly, if a certain number or range of rows is expected, you can verify that the total number of rows matches the expected number or range (with no rows remaining):</p><pre><span class="nctnt-pre ncbi-code">query.RequireRowCount(5);                // e.g. "expect exactly five rows";<br />query.RequireRowCount(100, kMax_Auto);   // or, "expect at least one hundred rows"<br />ITERATE(CQuery, qit, query) {<br />    // do something with the current result set row<br />}<br />query.VerifyDone(); // throws if the expected number of rows wasn't retrieved</span></pre><p><span class="nctnt highlight">Note: </span><span class="nctnt ncbi-func">VerifyDone()</span> is not a simple, read-only informational method. In its quest to determine if any result sets or rows remain unread, it will read and purge any unread rows. Furthermore, it doesn't return <span class="nctnt ncbi-type">bool</span> to indicate whether all expected records have been read. Instead, it throws an exception (after reading and purging) if all records had not been read prior to its call, or if the number of read rows was unexpected per <span class="nctnt ncbi-func">RequireRowCount()</span>.</p></div><div class="sec" id="ch_dbapi.Getting_a_Stored_Procedure_Retu"><h3><span class="title">Getting a Stored Procedure Return Value</span></h3><p>To get the return value from a stored procedure, simply call <span class="nctnt ncbi-func">GetStatus()</span>.</p></div><div class="sec" id="ch_dbapi.MetaData_Accessors"><h3><span class="title">Meta-Data Accessors</span></h3><p>A handful of accessors are available for query meta-data:</p><ul><li><p><span class="nctnt ncbi-func">GetColumnName()</span> -- Gets the name of the given column in the current result set.</p></li><li><p><span class="nctnt ncbi-func">GetColumnType()</span> -- Gets the type of the given column in the current result set.</p></li><li><p><span class="nctnt ncbi-func">GetRowCount()</span> -- Gets the number of rows read after a statement is executed.</p></li><li><p><span class="nctnt ncbi-func">GetStatus()</span> -- Gets the value returned from a stored procedure.</p></li><li><p><span class="nctnt ncbi-func">GetTotalColumns()</span> -- Gets the number of columns in the current result set.</p></li></ul><p><span class="nctnt highlight">Note:</span> These accessors are intended to be used after retrieving the results - they will result in exceptions if called before all data is read. The API doesn't include any accessors for the same information prior to reading the data.</p></div><div class="sec" id="ch_dbapi.Working_with_NULL"><h3><span class="title">Working with NULL</span></h3><p>SDBAPI, as a "simple" database API, does not provide a separate <span class="nctnt ncbi-monospace">NULL</span> value. To set an input parameter to <span class="nctnt ncbi-monospace">NULL</span>:</p><pre><span class="nctnt-pre ncbi-code">query.SetNullParameter("@some_param", eSDB_Int);</span></pre><p>To determine if a output parameter result is <span class="nctnt ncbi-monospace">NULL</span>:, call <span class="nctnt ncbi-func">IsNull()</span>:</p><pre><span class="nctnt-pre ncbi-code">ITERATE(CQuery, qit, query) {<br />    if (qit["id"].IsNull()) {<br />        // handle NULL<br />    } else {<br />        x = qit["id"].AsInt4(); // OK to use the converted value<br />    }</span></pre><p><span class="nctnt highlight">Note:</span> The <span class="nctnt ncbi-func">As*()</span> methods will return default values (e.g. zero or an empty string) when the actual result value is <span class="nctnt ncbi-monospace">NULL</span>. The only way to know if a <span class="nctnt ncbi-monospace">NULL</span> result was converted is to call <span class="nctnt ncbi-func">IsNull()</span>. Therefore, if you need to distinguish between <span class="nctnt ncbi-monospace">NULL</span> and default values, you <b>must</b> call <span class="nctnt ncbi-func">IsNull()</span>.</p></div><div class="sec" id="ch_dbapi.Using_Transactions"><h3><span class="title">Using Transactions</span></h3><p>SDBAPI does not provide any special API support for transactions, so simply run, for example:</p><pre><span class="nctnt-pre ncbi-code">m_Db.NewQuery("BEGIN TRAN").Execute();</span></pre></div><div class="sec" id="ch_dbapi.Using_Cursors"><h3><span class="title">Using Cursors</span></h3><p>SDBAPI does not support cursors. If you need cursors, you must use <a href="ch_dbapi.html#ch_dbapi.dbapi_user_layer">DBAPI</a>.</p></div></div><div class="sec" id="ch_dbapi.The_DBAPI_Library"><h2><span class="title">The DBAPI Library</span></h2><div class="sec" id="ch_dbapi.dbapi_user_layer"><h3><span class="title">DBAPI User-Layer Reference</span></h3><div class="sec" id="ch_dbapi.dbapi_overview"><h4><span class="title">DBAPI Overview</span></h4><p>DBAPI is a consistent, object-oriented programming interface to multiple back-end databases. It encapsulates leading relational database vendors' APIs and is universal for all applications regardless of which database is used. It frees developers from dealing with the low-level details of a particular database vendor's API, allowing them to concentrate on domain-specific issues and build appropriate data models. It allows developers to write programs that are reusable with many different types of relational databases and to drill down to the native database APIs for added control when needed.</p><p>DBAPI has open SQL interface. It takes advantage of database-specific features to maximize performance and allows tight control over statements and their binding and execution semantics.</p><p>DBAPI has "Native" Access Modules for Sybase, Microsoft SQL Server, SQLITE, and ODBC. It provides native, high-performance implementations for supported vendor databases. It allows porting to other databases with minimal code changes.</p><p>DBAPI is split into low-layer and user-layer.</p><p>In addition, a simplified C++ API (<a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">SDBAPI</a>) layer is provided for cases where the full DBAPI feature set is not required.</p><p>See the <a href="ch_libconfig.html#ch_libconfig.DBAPI">DBAPI configuration parameters reference</a> for details on configuring the DBAPI library.</p><p>See the DBAPI sample programs for example code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/</a></p></li></ul><p>The following sections cover specific aspects of DBAPI in detail.</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_hierarchy">Object Hierarchy</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_includes">Includes</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_objects">Objects</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_obj_lifecycle">Object Life Cycle</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_variant">CVariant Type</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_choose_driver">Choosing the Driver</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_src_cnxns">Data Source and Connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_main_loop">Main Loop</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_io_params">Input and Output Parameters</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_stored_procs">Stored Procedures</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_cursors">Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_wwblobs">Working with BLOBs</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_blobs">Updating BLOBs Using Cursors</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_bulk_insert">Using Bulk Insert</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_diag">Diagnostic Messages</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_trace">Trace Output</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_obj_hierarchy"><h4><span class="title">Object Hierarchy</span></h4><p>See <a href="ch_dbapi.html#ch_dbapi.F1">Figure 1</a>.</p><div class="figure" id="ch_dbapi.F1"><div class="graphic"><a href="img/dbapi_user.gif" class="img_link" target="_blank" title="Click to see the full-resolution image"><img id="ch_dbapi.dbapi_user.gif" src="img/dbapi_user.gif" alt="Figure 1. Object Hierarchy" /></a></div><div class="caption"><p>Figure 1. Object Hierarchy</p></div></div></div><div class="sec" id="ch_dbapi.dbapi_includes"><h4><span class="title">Includes</span></h4><p>For most purposes it is sufficient to include one file in the user source file: <span class="nctnt ncbi-path">dbapi.hpp</span>.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/dbapi.hpp&gt;</span></pre><p>For static linkage the following include file is also necessary:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/driver/drivers.hpp&gt;</span></pre></div><div class="sec" id="ch_dbapi.dbapi_objects"><h4><span class="title">Objects</span></h4><p>All objects are returned as pointers to their respective interfaces. The null (0) value is valid, meaning that no object was returned.</p></div><div class="sec" id="ch_dbapi.dbapi_obj_lifecycle"><h4><span class="title">Object Life Cycle</span></h4><p>In general, any child object is valid only in the scope of its parent object. This is because most of the objects share the same internal structures. There is no need to delete every object explicitly, as all created objects will be deleted upon program exit. Specifically, all objects are managed by the static <span class="nctnt ncbi-class">CDriverManager</span> object, and will be destroyed when <span class="nctnt ncbi-class">CDriverManager</span> is destroyed. It is possible to delete any object from the framework and it is deleted along with all derived objects. For example, when an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a> object is deleted, all derived <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> objects will be deleted too. If the number of the objects (for instance <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a>) is very high, it is recommended to delete them explicitly or enclose in the <span class="nctnt ncbi-type">auto_ptr&lt;...&gt;</span> template. For each object a <span class="nctnt ncbi-func">Close()</span> method is provided. It disposes of internal resources, required for the proper library cleanup, but leaves the framework intact. After calling <span class="nctnt ncbi-func">Close()</span> the object becomes invalid. This method may be necessary when the database cleanup and framework cleanup are performed in different places of the code.</p></div><div class="sec" id="ch_dbapi.dbapi_variant"><h4><span class="title">CVariant Type</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> type is used to represent any database data type (except BLOBs). It is an object, not a pointer, so it behaves like a primitive C++ type. Basic comparison operators are supported (==, !=, &lt; ) for identical internal types. If types are not identical, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariantException.html">CVariantException</a> is thrown. <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> has a set of getters to extract a value of a particular type, e.g. <span class="nctnt ncbi-func">GetInt4()</span>, <span class="nctnt ncbi-func">GetByte()</span>,<span class="nctnt ncbi-func"> GetString()</span>, etc. If <span class="nctnt ncbi-func">GetString()</span> is called for a different type, like <span class="nctnt ncbi-type">DateTime</span> or <span class="nctnt ncbi-type">integer</span> it tries to convert it to a string. If it doesn't succeed, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariantException.html">CVariantException</a> is thrown. There is a set of factory methods (static functions) for creating <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> objects of a particular type, such as <span class="nctnt ncbi-func">CVariant::BigInt()</span>, <span class="nctnt ncbi-func">CVariant::SmallDateTime()</span>, <span class="nctnt ncbi-func">CVariant::VarBinary()</span> etc. For more details please see the comments in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/variant.hpp">variant.hpp</a> file.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_object.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_object.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_choose_driver"><h4><span class="title">Choosing the Driver</span></h4><p>There are two drivers for working with different SQL servers on different platforms. The ones presently implemented are "<span class="nctnt ncbi-lib">ftds</span>" (MS SQL, Sybase, cross platform) and "<span class="nctnt ncbi-lib">ctlib</span>" (Sybase). For static linkage these drivers should be registered manually; for dynamic linkage this is not necessary. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDriverManager.html">CDriverManager</a> object maintains all registered drivers. Manual registration is done with the RegisterDriver functions:</p><pre><span class="nctnt-pre ncbi-code">DBAPI_RegisterDriver_FTDS();<br />DBAPI_RegisterDriver_CTLIB();</span></pre><p><span class="nctnt highlight">Note:</span> FTDS is the primary driver and should be used unless there's a very specific reason why CTLIB must be used. Also, CTLIB is limited to Linux and Solaris connecting to Sybase.</p><p>As of July, 2014, there were a couple of issues with FTDS to be aware of:</p><ul><li><p>When using FTDS to connect to SQL Server, there are some limitations in updating LOB-fields which participate in replication.</p></li><li><p>When using FTDS to connect to Sybase Open Server, you must explicitly set TDS version to 5.0, otherwise the connect operation will hang. Also, explicitly configuring the packet size setting to 3584 (7 * 512) has historically been helpful.</p></li></ul><p>More details on <a href="http://intranet.ncbi.nlm.nih.gov:6224/wiki-private/CxxToolkit/index.cgi/Recommended_DBAPI_drivers">recommended drivers</a> are available to users inside NCBI.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_context.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_context.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_src_cnxns"><h4><span class="title">Data Source and Connections</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIDataSource.html">IDataSource</a> interface defines the database platform. To create an object implementing this interface, use the method <span class="nctnt ncbi-func">CreateDs(const string&amp; driver)</span>. An <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIDataSource.html">IDataSource</a> can create objects represented by an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a> interface, which is responsible for the connection to the database. It is highly recommended to specify the database name as an argument to the <span class="nctnt ncbi-func">CreateConnection()</span> method, or use the <span class="nctnt ncbi-func">SetDatabase()</span> method of a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCConnection.html">CConnection</a> object instead of using a regular SQL statement. In the latter case, the library won't be able to track the current database.</p><pre><span class="nctnt-pre ncbi-code">IDataSource *ds = dm.CreateDs("ctlib");<br />IConnection *conn = ds-&gt;CreateConnection();<br />conn-&gt;Connect("user", "password", "server", "database");<br />IStatement *stmt = conn-&gt;CreateStatement();</span></pre><p>Every additional call to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a><span class="nctnt ncbi-func">::CreateStatement()</span> results in cloning the connection for each statement. These connections inherit the same default database, which was specified in the <span class="nctnt ncbi-func">Connect()</span> or <span class="nctnt ncbi-func">SetDatabase()</span> method. Thus if the default database was changed by calling <span class="nctnt ncbi-func">SetDatabase()</span>, all subsequent cloned connections created by <span class="nctnt ncbi-func">CreateStatement()</span> will inherit this particular default database.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_connection.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_connection.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_main_loop"><h4><span class="title">Main Loop</span></h4><p>The library simulates the main result-retrieving loop of the Sybase client library by using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::HasMoreResults()</span> method:</p><pre><span class="nctnt-pre ncbi-code">stmt-&gt;Execute("select * from MyTable");<br />while( stmt-&gt;HasMoreResults() ) {<br />    if( stmt-&gt;HasRows() ) {<br />        IResultSet *rs = stmt-&gt;GetResultset();<br /><br />        // Retrieve results, if any<br /><br />        while( rs-&gt;Next() ) {<br />            int col1 = rs-&gt;GetVariant(1).GetInt4();<br />            ...<br />        }<br />    }<br />}</span></pre><p>This method should be called until it returns <span class="nctnt ncbi-monospace">false</span>, which means that no more results are available. It returns as soon as a result is ready. The type of the result can be obtained by calling the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetResultType()</span> method. Supported result types are <span class="nctnt ncbi-var">eDB_RowResult, eDB_ParamResult, eDB_ComputeResult, eDB_StatusResult, eDB_CursorResult</span>. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::GetRowCount()</span> returns the number of updated or deleted rows.</p><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::ExecuteUpdate()</span> method is used for SQL statements that do not return rows:</p><pre><span class="nctnt-pre ncbi-code">stmt-&gt;ExecuteUpdate("update...");<br />int rows = stmt-&gt;GetRowCount();</span></pre><p>The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a><span class="nctnt ncbi-func">::GetResultSet()</span> returns an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> object. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::Next()</span> actually does the fetching, so it should be always called first. It returns <span class="nctnt ncbi-monospace">false</span> when no more fetch data is available. All column data, except Image and Text is represented by a single <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> object. The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetVariant()</span> takes one parameter, the column number. Column numbers start with 1.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_stmt.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_stmt.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_io_params"><h4><span class="title">Input and Output Parameters</span></h4><p>The method <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::SetParam(const CVariant&amp; v, const string&amp; name)</span> is used to pass parameters to stored procedures and dynamic SQL statements. To ensure the correct parameter type it is recommended to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> type factories (static methods) to create a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> of the required internal type. There is no internal representation for the BIT parameter type, please use TinyInt of Int types with 0 for <span class="nctnt ncbi-monospace">false</span> and 1 for <span class="nctnt ncbi-monospace">true</span> respectively. Here are a few examples: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Int4(Int4 *p)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::TinyInt(UInt1 *p)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::VarChar(const char *p, size_t len )</span> etc.</p><p>There are also corresponding constructors, like <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::CVariant(Int4 v)</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::CVariant(const string&amp; s)</span>, ..., but the user must ensure the proper type conversion in the arguments, and not all internal types can be created using constructors.</p><p>Output parameters are set by the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::SetOutputParam(const CVariant&amp; v, const string&amp; name)</span> method, where the first argument is a null <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> of a particular type, e.g. <span class="nctnt ncbi-code">SetOutputParam(CVariant(eDB_SmallInt),"@arg")</span>.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_stored_procs"><h4><span class="title">Stored Procedures</span></h4><p>The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> object is used for calling stored procedures. First get the object itself by calling <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIConnection.html">IConnection</a><span class="nctnt ncbi-func">::PrepareCall()</span>. Then set any parameters. If the parameter name is empty, the calls to <span class="nctnt ncbi-func">SetParam()</span> should be in the exact order of the actual parameters. Retrieve all results in the main loop. Get the status of the stored procedure using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a><span class="nctnt ncbi-func">::GetReturnStatus()</span> method.</p><pre><span class="nctnt-pre ncbi-code">ICallableStatement *cstmt = conn-&gt;PrepareCall("ProcName");<br />Uint1 byte = 1;<br />cstmt-&gt;SetParam(CVariant("test"), "@test_input");<br />cstmt-&gt;SetParam(CVariant::TinyInt(&amp;byte), "@byte");<br />cstmt-&gt;SetOutputParam(CVariant(eDB_Int), "@result");<br />cstmt-&gt;Execute();<br />while(cstmt-&gt;HasMoreResults()) {<br />    if( cstmt-&gt;HasRows() ) {<br />        IResultSet *rs = cstmt-&gt;GetResultSet();<br />        switch( rs-&gt;GetResultType() ) {<br />            case eDB_RowResult:<br />                while(rs-&gt;Next()) {<br /><br />                // retrieve row results<br /><br />                }<br />                break;<br />            case eDB_ParamResult:<br />                while(rs-&gt;Next()) {<br /><br />                // Retrieve parameter row<br /><br />                }<br />                break;<br />        }<br />    }<br />}<br /><br />// Get status<br />int status = cstmt-&gt;GetReturnStatus();</span></pre><p>It is also possible to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a> interface to call stored procedures using standard SQL language call. The difference from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICallableStatement.html">ICallableStatement</a> is that there is no <span class="nctnt ncbi-func">SetOutputParam()</span> call. The output parameter is passed with a regular <span class="nctnt ncbi-func">SetParam()</span> call having a <i>non-null </i><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> argument. There is no <span class="nctnt ncbi-func">GetReturnStatus()</span> call in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a>, so use the result type filter to get it - although note that result sets with type <span class="nctnt ncbi-monospace">eDB_StatusResult</span> are not always guaranteed to be returned when using the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIStatement.html">IStatement</a> interface.</p><pre><span class="nctnt-pre ncbi-code">sql = "exec SampleProc @id, @f, @o output";<br />stmt-&gt;SetParam(CVariant(5), "@id");<br />stmt-&gt;SetParam(CVariant::Float(&amp;f), "@f");<br />stmt-&gt;SetParam(CVariant(5), "@o");<br />stmt-&gt;Execute(sql);<br />while(stmt-&gt;HasMoreResults()) {<br />    IResultSet *rs = stmt-&gt;GetResultSet();<br /><br />    if( rs == 0 )<br />        continue;<br /><br />    switch( rs-&gt;GetResultType() ) {<br />    case eDB_ParamResult:<br />        while( rs-&gt;Next() ) {<br />            NcbiCout &lt;&lt; "Output param: "<br />                     &lt;&lt; rs-&gt;GetVariant(1).GetInt4()<br />                     &lt;&lt; NcbiEndl;<br />        }<br />        break;<br />    case eDB_StatusResult:<br />        while( rs-&gt;Next() ) {<br />            NcbiCout &lt;&lt; "Return status: "<br />                     &lt;&lt; rs-&gt;GetVariant(1).GetInt4()<br />                     &lt;&lt; NcbiEndl;<br />        }<br />        break;<br />    case eDB_RowResult:<br />        while( rs-&gt;Next() ) {<br />            if( rs-&gt;GetVariant(1).GetInt4() == 2121 ) {<br />                NcbiCout &lt;&lt; rs-&gt;GetVariant(2).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(3).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(4).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(5).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(6).GetString() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(7).GetString() &lt;&lt; "|"<br />                         &lt;&lt; NcbiEndl;<br />            } else {<br />                NcbiCout &lt;&lt; rs-&gt;GetVariant(1).GetInt4() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant(2).GetFloat() &lt;&lt; "|"<br />                         &lt;&lt; rs-&gt;GetVariant("date_val").GetString() &lt;&lt; "|"<br />                         &lt;&lt; NcbiEndl;<br />            }<br />        }<br />        break;<br />    }<br />}<br />stmt-&gt;ClearParamList();</span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/dbapi/dbapi_simple.cpp</a></p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_proc.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_proc.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_cursors"><h4><span class="title">Cursors</span></h4><p>The library currently supports basic cursor features such as setting parameters and cursor update and delete operations.</p><pre><span class="nctnt-pre ncbi-code">ICursor *cur = conn-&gt;CreateCursor("table_cur",<br />                                  "select ... for update of ...");<br />IResultSet *rs = cur-&gt;Open();<br />while(rs-&gt;Next()) {<br />    cur-&gt;Update(table, sql_statement_for_update);<br />}<br />cur-&gt;Close();</span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_cursor.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_cursor.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_wwblobs"><h4><span class="title">Working with BLOBs</span></h4><p>Due to the possibly very large size, reading and writing BLOBs requires special treatment. During the fetch the contents of the whole column must be read before advancing to the next one. That's why the columns of type IMAGE and TEXT are not bound to the corresponding variables in the resultset and all subsequent columns are not bound either. So it is recommended to put the BLOB columns at the end of the column list. There are several ways to read BLOBs, using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::Read()</span>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobIStream()</span>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobReader()</span> methods. The first is the most efficient; it reads data into a supplied buffer until it returns 0 bytes read. The next call will read from the next column. The second method implements the STL istream interface. After each successful column read you should get another istream for the next column. The third implements the C++ Toolkit <span class="nctnt ncbi-func">IReader</span> interface. If the data size is small and double buffering is not a performance issue, the BLOB columns can be bound to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> variables by calling <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::BindBlobToVariant(true)</span>. In this case the data should be read using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Read()</span> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::GetBlobSize()</span>. To write BLOBs there are also several options. To pass a BLOB as a SQL parameter you should store it in a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a> using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Append()</span> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCVariant.html">CVariant</a><span class="nctnt ncbi-func">::Truncate()</span> methods. To store a BLOB in the database you should initialize this column first by writing a zero value (<span class="nctnt ncbi-var">0x0</span>) for an IMAGE type or a space value (<span class="nctnt ncbi-monospace">' '</span>) for a TEXT type. After that you can open a regular <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a> or <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classICursor.html">ICursor</a> and for each required row update the BLOB using <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classIResultSet.html">IResultSet</a><span class="nctnt ncbi-func">::GetBlobOStream()</span>. NOTE: this call opens an additional connection to the database.</p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_lob.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_lob.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_blobs"><h4><span class="title">Updating BLOBs Using Cursors</span></h4><p>It is recommended to update BLOBs using cursors, because no additional connections are opened and this is the only way to work with ODBC drivers.</p><pre><span class="nctnt-pre ncbi-code">ICursor *blobCur = conn-&gt;CreateCursor("test",<br />             "select id, blob from BlobSample for update of blob");<br />IResultSet *blobRs = blobCur-&gt;Open();<br />while(blobRs-&gt;Next()) {<br />    ostream&amp; out = blobCur-&gt;GetBlobOStream(2, blob.size());<br />    out.write(buf, blob.size());<br />    out.flush();<br />}</span></pre><p>Note that <span class="nctnt ncbi-func">GetBlobOStream()</span> takes the column number as the first argument and this call is invalid until the cursor is open.</p></div><div class="sec" id="ch_dbapi.dbapi_bulk_insert"><h4><span class="title">Using Bulk Insert</span></h4><p>Bulk insert is useful when it is necessary to insert big amounts of data. The <span class="nctnt ncbi-func">IConnection::CreateBulkInsert()</span> takes one parameter, the table name. The number of columns is determined by the number of <span class="nctnt ncbi-func">Bind()</span> calls. The <span class="nctnt ncbi-func">CVariant::Truncate(size_t len)</span> method truncates the internal buffer of CDB_Text and CDB_Image object from the end of the buffer. If no parameter specified, it erases the whole buffer.</p><pre><span class="nctnt-pre ncbi-code">NcbiCout &lt;&lt; "Initializing BlobSample table..." &lt;&lt; NcbiEndl;<br />IBulkInsert *bi = conn-&gt;CreateBulkInsert(tbl_name);<br />CVariant col1 = CVariant(eDB_Int);<br />CVariant col2 = CVariant(eDB_Text);<br />bi-&gt;Bind(1, &amp;col1);<br />bi-&gt;Bind(2, &amp;col2);<br />for(int i = 0; i &lt; ROWCOUNT; ++i ) {<br />    string im = "BLOB data " + NStr::IntToString(i);<br />    col1 = i;<br />    col2.Truncate();<br />    col2.Append(im.c_str(), im.size());<br />    bi-&gt;AddRow();<br />}<br />bi-&gt;Complete();<br /></span></pre><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_bcp.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_bcp.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_diag"><h4><span class="title">Diagnostic Messages</span></h4><p>The DBAPI library is integrated with the C++ Toolkit diagnostic and tracing facility. By default all client and server messages are handled by the Toolkit's standard message handler. However it is possible to redirect the DBAPI-specific messages to a single <span class="nctnt ncbi-class">CDB_MultiEx</span> object and retrieve them later at any time. There are two types of redirection, per data source and per connection. The redirection from a data source is enabled by calling <span class="nctnt ncbi-func">IDataSource::SetLogStream(0)</span>. After the call all client- and context-specific messages will be stored in the <span class="nctnt ncbi-func">IDataSource</span> object. The <span class="nctnt ncbi-func">IDataSource::GetErrorInfo()</span> method will return the string representation of all accumulated messages and clean up the storage. The <span class="nctnt ncbi-func">IDataSource::GetErrorAsEx()</span> will return a pointer to the underlying <span class="nctnt ncbi-class">CDB_MultiEx</span> object. Retrieving information and cleaning up is left to the developer. Do NOT delete this object. The connection-specific redirection is controlled by calling <span class="nctnt ncbi-func">IConnection::MsgToEx(boolean enable)</span> method. This redirection is useful; for instance, to temporarily disable default messages from the database server. The <span class="nctnt ncbi-func">IConnection::GetErrorInfo()</span> and <span class="nctnt ncbi-func">IConnection::GetErrorAsEx()</span> methods work in the same manner as for the <span class="nctnt ncbi-func">IDataSource</span></p><p>Related sample code:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_msg.cpp">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/test/dbapi_unit_test_msg.cpp</a></p></li></ul></div><div class="sec" id="ch_dbapi.dbapi_trace"><h4><span class="title">Trace Output</span></h4><p>The DBAPI library uses the Toolkit-wide DIAG_TRACE environment variable to do the debug output. To enable it set it to any value. If you have any problems with the DBAPI please include the trace output into your email.</p></div></div><div class="sec" id="ch_dbapi.dbapi_driver_ref"><h3><span class="title">DBAPI Driver Reference</span></h3><p>The following sections cover low-level access to the various RDBMSs:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_overview">Overview</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_arch">The driver architecture</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_errors">Error handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_context">Driver context and connections</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvr_mgr">Driver Manager</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_txt_img">Text and Image Data Handling</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_results">Results loop</a></p></li></ul><div class="sec" id="ch_dbapi.dbapi_drvr_overview"><h4><span class="title">Overview</span></h4><p>SDBAPI clients can only use <a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS</a>, but DBAPI clients must choose the lower-level driver.</p><p>The NCBI DBAPI driver library describes and implements a set of objects needed to provide a uniform low-level access to the various relational database management systems (RDBMS). The basic driver functionality is the same as in most other RDBMS client APIs. It allows opening a connection to a server, executing a command (query) on this connection and getting the results back. The main advantage of using the driver is that you don't have to change your own upper-level code if you need to move from one RDBMS client API to another.</p><p>The driver can use two different methods to access the particular RDBMS. If the RDBMS provides a client library for the given computer system (e.g. Sun/Solaris), then the driver uses that library. If no such client library exists, then the driver connects to an RDBMS through a special gateway server which is running on a computer system where such a library does exist.</p></div><div class="sec" id="ch_dbapi.dbapi_drvr_arch"><h4><span class="title">The driver architecture</span></h4><p>There are two major groups of the driver's objects: the RDBMS-independent objects, and the objects which are specific to a particular RDBMS. The only RDBMS-specific object which user should be aware of is a "Driver Context". The "Driver Context" is effectively a "Connection" factory. The only way to make a connection to the server is to call the <span class="nctnt ncbi-func">Connect()</span> method of a "Driver Context" object. So, before doing anything with an RDBMS, you need to create at least one driver context object. All driver contexts implement the same interface defined in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__DriverContext.html">I_DriverContext</a> class. If you are working on a library which could be used with more than one RDBMS, the driver context should not be created by the library. Instead, the library API should include a pointer to <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=I_DriverContext&amp;d=C">I_DriverContext</a> so an existing driver context can be passed in.</p><p>There is no "real" factory for driver contexts because it's not always possible to statically link the RDBMS libraries from different vendors into the same binary. Most of them are written in C and name collisions do exist. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=C_DriverMgr&amp;d=C">Driver Manager</a> helps to overcome this problem. It allows creating a mixture of statically linked and dynamically loaded drivers and using them together in one executable.</p><p>The driver context creates the connection which is RDBMS-specific, but before returning it to the caller it puts it into an RDBMS-independent "envelope", <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Connection.html">CDB_Connection</a>. The same is true for the commands and for the results - the user gets the pointer to the RDBMS-independent "envelope object" instead of the real one. It is the caller's responsibility to delete those objects. The life spans of the real object and the envelope object are not necessarily the same.</p><p>Once you have the connection object, you could use it as a factory for the different types of commands. The command object in turn serves as a factory for the results. The connection is always single threaded, that means that you have to execute the commands and process their results sequentially one by one. If you need to execute the several commands in parallel, you can do it using multiple connections.</p><p>Another important part of the driver is error and message handling. There are two different mechanisms implemented. The first one is exceptions. All exceptions which could be thrown by the driver are inherited from the single base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>. Drivers use the exception mechanism whenever possible, but in many cases the underlying client library uses callbacks or handlers to report error messages rather than throwing exceptions. The driver supplies a handler's stack mechanism to manage these cases.</p><p>To send and to receive the data through the driver you have to use the driver provided datatypes. The collection of the datatypes includes: <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__TinyInt.html">one</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SmallInt.html">two</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Int.html">four</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__BigInt.html">eight</a> byte integers; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Float.html">float</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Double.html">double</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Numeric.html">numeric</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Char.html">char</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__VarChar.html">varchar</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Binary.html">binary</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__VarBinary.html">varbinary</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DateTime.html">datetime</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SmallDateTime.html">smalldatetime</a>; <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Text.html">text</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Image.html">image</a>. All datatypes are derived from a single base class <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Object.html">CDB_Object</a>.</p></div><div class="sec" id="ch_dbapi.dbapi_sample_prog"><h4><span class="title">Sample program</span></h4><p>This program opens one connection to the server and selects the database names and the date when each database was created (assuming that table "sysdatabases" does exist). In this example the string "XXX" should be replaced with the real driver name.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */<br />#include &lt;dbapi/driver/XXXlib/interfaces.hpp&gt;<br />USING_NCBI_SCOPE;<br />int main()<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        // Preparing a SQL query<br />        CDB_LangCmd* lcmd =<br />            con-&gt;LangCmd("select name, crdate from sysdatabases");<br />        // Sending this query to a server<br />        lcmd-&gt;Send();<br />        CDB_Char dbname(64);<br />        CDB_DateTime crdate;<br />        // the result loop<br />        while(lcmd-&gt;HasMoreResults()) {<br />            CDB_Result* r= lcmd-&gt;Result();<br />            // skip all but row result<br />            if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />                delete r;<br />                continue;<br />            }<br />            // printing the names of selected columns<br />            NcbiCout &lt;&lt; r-&gt;ItemName(0) &lt;&lt; " \t\t\t"<br />                     &lt;&lt; r-&gt;ItemName(1) &lt;&lt; NcbiEndl;<br />            // fetching the rows<br />            while ( r-&gt;Fetch() ) {<br />                r-&gt;GetItem(&amp;dbname); // get the database name<br />                r-&gt;GetItem(&amp;crdate); // get the creation date<br />                NcbiCout &lt;&lt; dbname.Value() &lt;&lt; ' '<br />                         &lt;&lt; crdate.Value().AsString("M/D/Y h:m")<br />                         &lt;&lt; NcbiEndl;<br />            }<br />            delete r; // we don't need this result anymore<br />        }<br />        delete lcmd; // delete the command<br />        delete con;  // delete the connection<br />    }<br />    catch (CDB_Exception&amp; e) { // printing the error messages<br />        CDB_UserHandler_Stream myExHandler(&amp;cerr);<br />        myExHandler.HandleIt(&amp;e);<br />    }<br />}</span></pre></div><div class="sec" id="ch_dbapi.dbapi_errors"><h4><span class="title">Error handling</span></h4><p>Error handling is almost always a pain when you are working with an RDBMS because different systems implement different approaches. Depending on the system, you can get error messages through return codes, callbacks, handlers, and/or exceptions. These messages could have different formats. It could be just an integer (error code), a structure, or a set of callback's arguments. The NCBI DBAPI driver intercepts all those error messages in all different formats and converts them into various types of objects derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>.</p><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> provides the following methods for all exceptions:</p><ul><li><p><span class="nctnt ncbi-func">GetDBErrCode()</span> - returns the integer code for this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">SeverityString(void)</span> - returns the severity string of this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">GetErrCodeString()</span> - returns the name for this error code (e.g. "eSQL").</p></li><li><p><span class="nctnt ncbi-func">Type()</span> - returns the type value for this exception type (e.g. eSQL).</p></li><li><p><span class="nctnt ncbi-func">TypeString()</span> - returns the type string for this exception type (e.g. "eSQL"). This is a pass-through to <span class="nctnt ncbi-func">CException::GetType()</span>.</p></li><li><p><span class="nctnt ncbi-func">ErrCode()</span> - alias for <span class="nctnt ncbi-func">GetDBErrCode()</span>.</p></li><li><p><span class="nctnt ncbi-func">Message()</span> - returns the error message itself. This is a pass-through to <span class="nctnt ncbi-func">CException::GetMsg()</span>.</p></li><li><p><span class="nctnt ncbi-func">OriginatedFrom()</span> - returns the SQL server name. This is a pass-through to <span class="nctnt ncbi-func">CException::GetModule()</span>.</p></li><li><p><span class="nctnt ncbi-func">SetServerName()</span> - sets the SQL server name.</p></li><li><p><span class="nctnt ncbi-func">GetServerName()</span> - returns the SQL server name.</p></li><li><p><span class="nctnt ncbi-func">SetUserName()</span> - sets the SQL user name.</p></li><li><p><span class="nctnt ncbi-func">GetUserName()</span> - returns the SQL user name.</p></li><li><p><span class="nctnt ncbi-func">SetExtraMsg()</span> - sets extra message text to be included in the message output.</p></li><li><p><span class="nctnt ncbi-func">GetExtraMsg()</span> - gets the extra message text.</p></li><li><p><span class="nctnt ncbi-func">SetSybaseSeverity()</span> - sets the severity value for a Sybase exception - <span class="nctnt highlight">N.B.</span> Sybase severity values can be provided for the Sybase/FreeTDS ctlib driver only.</p></li><li><p><span class="nctnt ncbi-func">GetSybaseSeverity()</span> - gets the severity value for a Sybase exception - <span class="nctnt highlight">N.B.</span> Sybase severity values can be provided by the Sybase/FreeTDS ctlib driver only.</p></li><li><p><span class="nctnt ncbi-func">ReportExtra()</span> - outputs any extra text to the supplied stream.</p></li><li><p><span class="nctnt ncbi-func">Clone()</span> - creates a new exception based on this one.</p></li></ul><p><span class="nctnt highlight">N.B.</span> The following <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> methods are deprecated:</p><ul><li><p><span class="nctnt ncbi-func">Severity()</span> - returns the severity value of this message (assigned by SQL server).</p></li><li><p><span class="nctnt ncbi-func">SeverityString(EDB_Severity sev)</span> - returns the severity string of this message (assigned by SQL server).</p></li></ul><p>The DBAPI driver may throw any of the following types derived from <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a>:</p><ul><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SQLEx.html">CDB_SQLEx</a> This type is used if an error message has come from a SQL server and indicates an error in a SQL query. It could be a wrong table or column name or a SQL syntax error. This type provides the additional methods:</p><ul><li><p><span class="nctnt ncbi-func">BatchLine()</span> - returns the line number in the SQL batch that generated the error.</p></li><li><p><span class="nctnt ncbi-func">SqlState()</span> - returns a byte string describing an error (it's not useful most of the time).</p></li></ul></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__RPCEx.html">CDB_RPCEx</a> An error message has come while executing an RPC or stored procedure. This type provides the additional methods:</p><ul><li><p><span class="nctnt ncbi-func">ProcName()</span> - returns the procedure name where the exception originated.</p></li><li><p><span class="nctnt ncbi-func">ProcLine()</span> - returns the line number within the procedure where the exception originated.</p></li></ul></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DeadlockEx.html">CDB_DeadlockEx</a> An error message has come as a result of a deadlock.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__DSEx.html">CDB_DSEx</a> An error has come from an RDBMS and is not related to a SQL query or RPC.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__TimeoutEx.html">CDB_TimeoutEx</a> An error message has come due to a timeout.</p></li><li><p><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__ClientEx.html">CDB_ClientEx</a> An error message has come from the client side.</p></li></ul><p>Drivers use two ways to deliver an error message object to an application. If it is possible to throw an exception, then the driver throws the error message object. If not, then the driver calls the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__UserHandler.html">user's error handler</a> with a pointer to the error message object as an argument. It's not always convenient to process all types of error messages in one error handler. Some users may want to use a special error message handler inside some function or block and a default error handler outside. To accommodate these cases the driver provides a <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDBHandlerStack&amp;d=C">handler stack mechanism</a>. The top handler in the stack gets the error message object first. If it knows how to deal with this message, then it processes the message and returns <span class="nctnt ncbi-monospace">true</span>. If handler wants to pass this message to the other handlers, then it returns <span class="nctnt ncbi-monospace">false</span>. So, the driver pushes the error message object through the stack until it gets <span class="nctnt ncbi-monospace">true</span> from the handler. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__UserHandler__Stream.html">default driver's error handler</a>, which just prints the error message to <span class="nctnt ncbi-var">stderr</span>, is always on the bottom of the stack.</p><p>Another tool which users may want to use for error handling is the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__MultiEx.html">CDB_MultiEx</a> object. This tool allows collecting multiple <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__Exception.html">CDB_Exception</a> objects into one container and then throwing the container as one exception object.</p></div><div class="sec" id="ch_dbapi.dbapi_context"><h4><span class="title">Driver context and connections</span></h4><p>Every program which is going to work with an NCBI DBAPI driver should create at least one Driver Context object first. The main purpose of this object is to be a Connection factory, but it's a good idea to customize this object prior to opening a connection. The first step is to setup two message handler stacks. The first one is for error messages which are not bound to some particular connection or could occur inside the <span class="nctnt ncbi-func">Connect()</span> method. Use <span class="nctnt ncbi-func">PushCntxMsgHandler()</span> to populate it. The other stack serves as an initial message handler stack for all connections which will be derived from this context. Use <span class="nctnt ncbi-func">PushDefConnMsgHandler()</span> method to populate this stack. The second step of customization is setting timeouts. The <span class="nctnt ncbi-func">SetLoginTimeout()</span> and <span class="nctnt ncbi-func">SetTimeout()</span> methods do the job. If you are going to work with text or image objects in your program, you need to call <span class="nctnt ncbi-func">SetMaxTextImageSize()</span> to define the maximum size for such objects. Objects which exceed this limit could be truncated.</p><pre><span class="nctnt-pre ncbi-code">class CMyHandlerForConnectionBoundErrors : public CDB_UserHandler<br />{<br />    virtual bool HandleIt(CDB_Exception* ex);<br />    ...<br />};<br />class CMyHandlerForOtherErrors : public CDB_UserHandler<br />{<br />    virtual bool HandleIt(CDB_Exception* ex);<br />    ...<br />};<br />...<br />int main()<br />{<br />    CMyHandlerForConnectionBoundErrors conn_handler;<br />    CMyHandlerForOtherErrors           other_handler;<br />    ...<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        my_context.PushCntxMsgHandler(&amp;other_handler);<br />        my_context.PushDefConnMsgHandler(&amp;conn_handler);<br />        // set timeouts (in seconds) and size limits (in bytes):<br />        my_context.SetLoginTimeout(10); // for logins<br />        my_context.SetTimeout(15);      // for client/server communications<br />        my_context.SetMaxTextImageSize(0x7FFFFFFF); // text/image size limit<br />        ...<br />        CDB_Connection* my_con =<br />            my_context.Connect("MyServer", "my_user_name", "my_password",<br />                               I_DriverContext::fBcpIn);<br />        ...<br />    }<br />    catch (CDB_Exception&amp; e) {<br />        other_handler.HandleIt(&amp;e);<br />    }<br />}</span></pre><p>The only way to get a connection to a server in an NCBI DBAPI driver is through a <span class="nctnt ncbi-func">Connect()</span> method in <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__DriverContext.html">driver context</a>. The first three arguments: server name, user name and password are obvious. Values for <span class="nctnt ncbi-var">mode</span> are constructed by a bitwise-inclusive-OR of flags defined in EConnectionMode. If <span class="nctnt ncbi-var">reusable</span> is <span class="nctnt ncbi-monospace">false</span>, then driver creates a new connection which will be destroyed as soon as user delete the correspondent <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_Connection&amp;d=C">CDB_Connection</a> (the <span class="nctnt ncbi-var">pool_name</span> is ignored in this case).</p><p>Opening a connection to a server is an expensive operation. If program opens and closes connections to the same server multiple times it worth calling the <span class="nctnt ncbi-func">Connect()</span> method with <span class="nctnt ncbi-var">reusable</span> set to <span class="nctnt ncbi-monospace">true</span>. In this case driver does not close the connection when the correspondent CDB_Connection is deleted, but keeps it around in a "recycle bin". Every time an application calls the <span class="nctnt ncbi-func">Connect()</span> method with <span class="nctnt ncbi-var">reusable</span> set to <span class="nctnt ncbi-monospace">true</span>, driver tries to satisfy the request from a "recycle bin" first and opens a new connection only if necessary.</p><p>The <span class="nctnt ncbi-var">pool_name</span> argument is just an arbitrary string. An application could use this argument to assign a name to one or more connections (to create a connection pool) or to invoke a connection by name from this pool.</p><pre><span class="nctnt-pre ncbi-code">...<br />// Create a pool of four connections (two to one server and two to another)<br />// with the default database "DatabaseA"<br />CDB_Connection* con[4];<br />int i;<br />for (i = 4;  i--; ) {<br />    con[i]= my_context.Connect((i%2 == 0) ? "MyServer1" : "MyServer2",<br />                               "my_user_name", "my_password", 0, true,<br />                               "ConnectionPoolA");<br />    CDB_LangCmd* lcmd= con[i]-&gt;LangCmd("use DatabaseA");<br />    lcmd-&gt;Send();<br />    while(lcmd-&gt;HasMoreResults()) {<br />        CDB_Result* r = lcmd-&gt;Result();<br />        delete r;<br />    }<br />    delete lcmd;<br />}<br />// return all connections to a "recycle bin"<br />for(i= 0; i &lt; 4; delete con_array[i++]);<br />...<br />// in some other part of the program<br />// we want to get a connection from "ConnectionPoolA"<br />// but we don't want driver to open a new connection if pool is empty<br />try {<br />    CDB_Connection* my_con= my_context.Connect("", "", "", 0, true,<br />                                               "ConnectionPoolA");<br />    // Note that server name, user name and password are empty<br />    ...<br />}<br />catch (CDB_Exception&amp; e) {<br />    // the pool is empty<br />    ...<br />}</span></pre><p>An application could combine in one pool the connections to the different servers. This mechanism could also be used to group together the connections with some particular settings (default database, transaction isolation level, etc.).</p></div><div class="sec" id="ch_dbapi.dbapi_drvr_mgr"><h4><span class="title">Driver Manager</span></h4><p>It's not always known which NCBI DBAPI driver will be used by a particular program. Sometimes you want a driver to be a parameter in your program. Sometimes you need to use two different drivers in one binary but can not link them statically because of name collisions. Sometimes you just need the driver contexts factory. The <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=C_DriverMgr&amp;d=C">Driver Manager</a> is intended to solve these problems.</p><p>Let's rewrite our <a href="ch_dbapi.html#ch_dbapi.dbapi_sample_prog">Sample program</a> using the <span class="nctnt ncbi-monospace">Driver Manager</span>. The original text was.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />/* Here, XXXlib has to be replaced with the real name, e.g. "ctlib" */<br />#include &lt;dbapi/driver/XXXlib/interfaces.hpp&gt;<br />USING_NCBI_SCOPE;<br />int main()<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        // We need to create a driver context first<br />        // In real program we have to replace CXXXContext with something real<br />        CXXXContext my_context;<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context.Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        ...</span></pre><p>If we use the <span class="nctnt ncbi-monospace">Driver Manager</span> we could allow the driver name to be a program argument.</p><pre><span class="nctnt-pre ncbi-code">#include &lt;iostream&gt;<br />#include &lt;dbapi/driver/public.hpp&gt;<br />#include &lt;dbapi/driver/exception.hpp&gt;<br />#include &lt;dbapi/driver/driver_mgr.hpp&gt; // this is a new header<br />USING_NCBI_SCOPE;<br />int main(int argc, const char* argv[])<br />{<br />    try { // to be sure that we are catching all driver related exceptions<br />        C_DriverMgr drv_mgr;<br />        // We need to create a driver context first<br />        I_DriverContext* my_context= drv_mgr.GetDriverContext(<br />                                        (argc &gt; 1)? argv[1] : "ctlib");<br />        // connecting to server "MyServer"<br />        // with user name "my_user_name" and password "my_password"<br />        CDB_Connection* con = my_context-&gt;Connect("MyServer", "my_user_name",<br />                                                 "my_password", 0);<br />        ...</span></pre><p>This fragment creates an instance of the <span class="nctnt ncbi-monospace">Driver Manager</span>, dynamically loads the driver's library, implicitly registers this driver, creates the driver context and makes a connection to a server. If you don't want to load some drivers dynamically for any reason, but want to use the <span class="nctnt ncbi-monospace">Driver Manager</span> as a driver contexts factory, then you need to statically link your program with those libraries and explicitly register those using functions from <span class="nctnt ncbi-path">dbapi/driver/drivers.hpp</span> header.</p></div><div class="sec" id="ch_dbapi.dbapi_txt_img"><h4><span class="title">Text and Image Data Handling</span></h4><p><span class="nctnt ncbi-type">text</span> and <span class="nctnt ncbi-type">image</span> are SQL datatypes and can hold up to 2Gb of data. Because they could be huge, the RDBMS keeps these values separately from the other data in the table. In most cases the table itself keeps just a special pointer to a text/image value and the actual value is stored separately. This creates some difficulties for text/image data handling.</p><p>When you retrieve a large text/image value, you often prefer to "stream" it into your program and process it chunk by chunk rather than get it as one piece. Some RDBMS clients allow to stream the text/image values only if a corresponding column is the only column in a select statement.</p><p>Let's suppose that you have a table T (i_val int, t_val text) and you need to select all i_val, t_val where i_val &gt; 0. The simplest way is to use a query:</p><pre><span class="nctnt-pre ncbi-code">select i_val, t_val from T where i_val &gt; 0</span></pre><p>But it could be expensive. Because two columns are selected, some clients will put the whole row in a buffer prior to giving access to it to the user. The better way to do this is to use two selects:</p><pre><span class="nctnt-pre ncbi-code">select i_val from T where i_val &gt; 0<br />select t_val from T where i_val &gt; 0</span></pre><p>Looks ugly, but could save you a lot of memory.</p><p>Updating and inserting the text/image data is also not a straightforward process. For small texts and images it is possible to use just SQL <span class="nctnt ncbi-code">insert</span> and <span class="nctnt ncbi-code">update</span> statements, but it will be inefficient (if possible at all) for the large ones. The better way to insert and update text and image columns is to use the <span class="nctnt ncbi-func">SendData()</span> method of the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_Connection&amp;d=C">CDB_Connection</a> object or to use the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_SendDataCmd&amp;d=C">CDB_SendDataCmd</a> object.</p><p>The recommended algorithm for inserting text/image data is:</p><ul><li><p>Use a SQL <span class="nctnt ncbi-code">insert</span> statement to insert a new row into the table. Use a space value (<span class="nctnt ncbi-monospace">' '</span>) for each text column and a zero value (<span class="nctnt ncbi-monospace">0x0</span>) for each image column you are going to populate. Use <span class="nctnt ncbi-var">NULL</span> only if the value will remain <span class="nctnt ncbi-var">NULL</span>.</p></li><li><p>Use a SQL <span class="nctnt ncbi-code">select</span> statement to select all text/image columns from this row.</p></li><li><p>Fetch the row result and get an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__ITDescriptor.html">I_ITDescriptor</a> for each column.</p></li><li><p>Finish the results loop.</p></li><li><p>Use the <span class="nctnt ncbi-func">SendData()</span> method or <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SendDataCmd.html">CDB_SendDataCmd</a> object to populate the columns.</p></li></ul><p><span class="nctnt highlight">Example</span></p><p>Let's suppose that we want to insert a new row into table T as described above.</p><pre><span class="nctnt-pre ncbi-code">CDB_Connection* con;<br />...<br />// preparing the query<br />CDB_LangCmd* lcmd= con-&gt;LangCmd("insert T (i_val, t_val) values(100, ' ')\n");<br />lcmd-&gt;More("select t_val from T where i_val = 100");<br />// Sending this query to a server<br />lcmd-&gt;Send();<br />I_ITDescriptor* my_descr;<br />// the result loop<br />while(lcmd-&gt;HasMoreResults()) {<br />    CDB_Result* r= lcmd-&gt;Result();<br />    // skip all but row result<br />    if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />        delete r;<br />        continue;<br />    }<br />    // fetching the row<br />    while(r-&gt;Fetch()) {<br />        // read 0 bytes from the text (some clients need this trick)<br />        r-&gt;ReadItem(0, 0);<br />        my_deskr = r-&gt;GetImageOrTextDescriptor();<br />    }<br />    delete r; // we don't need this result anymore<br />}<br />delete lcmd; // delete the command<br />CDB_Text my_text;<br />my_text.Append("This is a text I want to insert");<br />//sending the text<br />con-&gt;SendData(my_descr, my_text);<br />delete my_descr; // we don't need this descriptor anymore<br />...</span></pre><p>The recommended algorithm for updating the text/image data is:</p><ul><li><p>Use a SQL <span class="nctnt ncbi-code">update</span> statement to replace the current value with a space value (<span class="nctnt ncbi-monospace">' '</span>) for a text column and a zero value (<span class="nctnt ncbi-monospace">0x0</span>) for an image column.</p></li><li><p>Use a SQL <span class="nctnt ncbi-code">select</span> statement to select all text/image columns you want to update in this row.</p></li><li><p>Fetch the row result and get an <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classI__ITDescriptor.html">I_ITDescriptor</a> for each column.</p></li><li><p>Finish the results loop.</p></li><li><p>Use the <span class="nctnt ncbi-func">SendData()</span> method or the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDB__SendDataCmd.html">CDB_SendDataCmd</a> object to populate the columns.</p></li></ul><p><span class="nctnt highlight">Example</span></p><pre><span class="nctnt-pre ncbi-code">CDB_Connection* con;<br />...<br />// preparing the query<br />CDB_LangCmd* lcmd= con-&gt;LangCmd("update T set t_val= ' ' where i_val =  100");<br />lcmd-&gt;More("select t_val from T where i_val = 100");<br />// Sending this query to a server<br />lcmd-&gt;Send();<br />I_ITDescriptor* my_descr;<br />// the result loop<br />while(lcmd-&gt;HasMoreResults()) {<br />    CDB_Result* r= lcmd-&gt;Result();<br />    // skip all but row result<br />    if (r == 0  ||  r-&gt;ResultType() != eDB_RowResult) {<br />        delete r;<br />        continue;<br />    }<br />    // fetching the row<br />    while(r-&gt;Fetch()) {<br />        // read 0 bytes from the text (some clients need this trick)<br />        r-&gt;ReadItem(0, 0);<br />        my_deskr = r-&gt;GetImageOrTextDescriptor();<br />    }<br />    delete r; // we don't need this result anymore<br />}<br />delete lcmd; // delete the command<br />CDB_Text my_text;<br />my_text.Append("This is a text I want to see as an update");<br />//sending the text<br />con-&gt;SendData(my_descr, my_text);<br />delete my_descr; // we don't need this descriptor anymore<br />...</span></pre></div><div class="sec" id="ch_dbapi.dbapi_results"><h4><span class="title">Results loop</span></h4><p>Each connection in the NCBI DBAPI driver is always single threaded. Therefore, applications have to retrieve all the results from a current command prior to executing a new one. Not all results are meaningful (i.e. an RPC always returns a status result regardless of whether or not a procedure has a return statement), but all results need to be retrieved. The following loop is recommended for retrieving results from all types of commands:</p><pre><span class="nctnt-pre ncbi-code">CDB_XXXCmd* cmd; // XXX could be Lang, RPC, etc.<br />...<br />while (cmd-&gt;HasMoreResults()) {<br />        // HasMoreResults() method returns true        // if the Result() method needs to be called.<br />        // It doesn't guarantee that Result() will return not NULL result<br />   CDB_Result* res = cmd-&gt;Result();<br />   if (res == 0)<br />       continue; // a NULL res doesn't mean that there is no more results<br />   switch(res-&gt;ResultType()) {<br />      case eDB_RowResult: // row result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_ParamResult: // Output parameters<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_ComputeResult: // Compute result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_StatusResult: // Status result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />      case eDB_CursorResult: // Cursor result<br />          while(res-&gt;Fetch()) {<br />             ...<br />          }<br />          break;<br />   }<br />   delete res;<br />}</span></pre><p>If you don't want to process some particular type of result, just skip the <span class="nctnt ncbi-code">while (res-&gt;Fetch()){...}</span> in the corresponding <span class="nctnt ncbi-code">case</span>.</p></div></div><div class="sec" id="ch_dbapi.dbapi_drivers"><h3><span class="title">Supported DBAPI drivers</span></h3><p>The following sections cover the supported DBAPI drivers:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.free_tds64">FreeTDS (TDS ver. 7.0)</a> -- this is the preferred driver</p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvs_ctlib">Sybase CTLIB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.dbapi_drvrs_odbc">ODBC</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.mysql_driver">MySQL Driver</a></p></li></ul><div class="sec" id="ch_dbapi.free_tds64"><h4><span class="title">FreeTDS (TDS ver. 7.0)</span></h4><p><span class="nctnt highlight">Note:</span> This is the only driver supported by SDBAPI.</p><p>This driver is the most recommended, built-in, and portable.</p><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_FTDS&amp;d=f">DBAPI_RegisterDriver_FTDS()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-lib">"ftds"</span>.</p></li><li><p>Driver library <span class="nctnt ncbi-lib">ncbi_xdbapi_ftds</span></p></li><li><p><span class="nctnt ncbi-monospace">FreeTDS</span> libraries and headers used by the driver <a href="ch_config.html#ch_config.ch_configlocalizatio">$(FTDS_LIBS)</a> <a href="ch_config.html#ch_config.ch_configlocalizatio">$(FTDS_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">FreeTDS</span>-specific driver context attributes "version", default = <span class="nctnt ncbi-monospace">&lt;DBVERSION_UNKNOWN&gt;</span> (also allowed: <span class="nctnt ncbi-monospace">"42"</span>, <span class="nctnt ncbi-monospace">"46"</span>, "70", "100")</p></li><li><p>FreeTDS works on UNIX and Windows platforms.</p></li><li><p>This driver supports Windows Domain Authentication using protocol NTLMv2, which is a default authentication protocol for Windows at NCBI.</p></li><li><p>This driver supports TDS protocol version auto-detection. TDS protocol version cannot be detected when connecting against Sybase Open Server.</p></li><li><p>Caveats:</p><ul><li><p>Default version of the TDS protocol (&lt;DBVERSION_UNKNOWN&gt;) will work with both MS SQL Server and Sybase SQL Server.</p></li><li><p>When using FTDS to connect to SQL Server, there are some limitations in updating LOB-fields which participate in replication.</p></li><li><p>When using FTDS to connect to Sybase Open Server, you must explicitly set TDS version to 5.0, otherwise the connect operation will hang. This can be done either by using a driver parameter "version" equal to "50" or by setting an environment variable TDSVER to "50". Also, explicitly configuring the packet size setting to 3584 (7 * 512) has historically been helpful.</p></li><li><p>Although a slightly modified version of FreeTDS is now part of the C++ Toolkit, it retains its own license: the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/dbapi/driver/ftds64/freetds/COPYING.LIB">GNU Library General Public License</a>.</p></li><li><p>TDS protocol version 4.2 should not be used with MS SQL server.</p></li></ul></li></ul></div><div class="sec" id="ch_dbapi.dbapi_drvs_ctlib"><h4><span class="title">Sybase CTLIB</span></h4><p><span class="nctnt highlight">Note:</span> This driver is not supported by SDBAPI.</p><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_CTLIB&amp;d=f">DBAPI_RegisterDriver_CTLIB()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-monospace">"ctlib"</span></p></li><li><p>Driver library <span class="nctnt ncbi-lib">ncbi_xdbapi_ctlib</span></p></li><li><p><span class="nctnt ncbi-monospace">Sybase CTLIB</span> libraries and headers used by the driver (UNIX) <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_LIBS)</a> <a href="ch_config.html#ch_config.ch_configlocalizatio">$(SYBASE_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">Sybase CTLIB</span> libraries and headers used by the driver (MS Windows). You will need the Sybase OpenClient package installed on your PC. In MSVC++, set the "C/C++ / General / Additional Include Directories" and "Linker / General / Additional Library Directories" properties to the Sybase OpenClient headers and libraries (for example "C:\Sybase\include" and "C:\Sybase\lib" respectively). Also set the "Linker / Input / Additional Dependencies" property to include the needed Sybase OpenClient libraries: <span class="nctnt ncbi-lib">LIBCT.LIB LIBCS.LIB LIBBLK.LIB</span>. To run the application, you must set environment variable <span class="nctnt ncbi-monospace">%SYBASE%</span> to the Sybase OpenClient root directory (e.g. "<span class="nctnt ncbi-path">C:\Sybase</span>"), and also to have your "interfaces" file there, in <span class="nctnt ncbi-path">INI/sql.ini</span>. In NCBI, we have the Sybase OpenClient libs installed in <span class="nctnt ncbi-path">\\snowman\win-coremake\Lib\ThirdParty\sybase</span>.</p></li><li><p>CTLIB-specific header (contains non-portable extensions) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver/ctlib/interfaces.hpp">dbapi/driver/ctlib/interfaces.hpp</a></p></li><li><p>CTLIB-specific driver context attributes "reuse_context" (default value is <span class="nctnt ncbi-monospace">"true"</span>), "version" (default value is <span class="nctnt ncbi-monospace">"125"</span>, also allowed <span class="nctnt ncbi-monospace">"100"</span> and <span class="nctnt ncbi-monospace">"110"</span>)</p></li><li><p>Caveats:</p><ul><li><p>Cannot communicate with MS SQL server using any TDS version.</p></li></ul></li></ul></div><div class="sec" id="ch_dbapi.dbapi_drvrs_odbc"><h4><span class="title">ODBC</span></h4><p><span class="nctnt highlight">Note:</span> This driver is not supported by SDBAPI.</p><ul><li><p>Registration function (for the manual, static registration) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=DBAPI_RegisterDriver_ODBC&amp;d=f">DBAPI_RegisterDriver_ODBC()</a></p></li><li><p>Driver default name (for the run-time loading from a DLL) <span class="nctnt ncbi-monospace">"odbc"</span></p></li><li><p>Driver library <span class="nctnt ncbi-lib">dbapi_driver_odbc</span></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span> libraries and headers used by the driver (MS Windows) <span class="nctnt ncbi-lib">ODBC32.LIB ODBCCP32.LIB ODBCBCP.LIB</span></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span> libraries and headers used by the driver (UNIX) <a href="ch_config.html#ch_config.ch_configlocalizatio">$(ODBC_LIBS)</a><a href="ch_config.html#ch_config.ch_configlocalizatio">$(ODBC_INCLUDE)</a></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span>-specific header (contains <span class="nctnt ncbi-monospace">non-portable</span> extensions) <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/dbapi/driver/odbc/interfaces.hpp">dbapi/driver/odbc/interfaces.hpp</a></p></li><li><p><span class="nctnt ncbi-monospace">ODBC</span>-specific driver context attributes "version" (default value is <span class="nctnt ncbi-monospace">"3"</span>, also allowed <span class="nctnt ncbi-monospace">"2"</span>), "use_dsn" (default value is <span class="nctnt ncbi-monospace">false</span>, if you have set this attribute to <span class="nctnt ncbi-monospace">true</span>, you need to define your <span class="nctnt ncbi-monospace">data source</span> using <span class="nctnt ncbi-monospace">"Control Panel"/"Administrative Tools"/"Data Sources (ODBC)"</span>)</p></li><li><p>Caveats:</p><ul><li><p>The <span class="nctnt ncbi-func">CDB_Result::GetImageOrTextDescriptor()</span> does not work for ODBC driver. You need to use <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_ITDescriptor&amp;d=C">CDB_ITDescriptor</a> instead. The other way to deal with <span class="nctnt ncbi-type">texts/images</span> in ODBC is through the <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CDB_CursorCmd&amp;d=C">CDB_CursorCmd</a> methods: <span class="nctnt ncbi-func">UpdateTextImage</span> and <span class="nctnt ncbi-func">SendDataCmd</span>.</p></li><li><p>On most NCBI PCs, there is an old header <span class="nctnt ncbi-path">odbcss.h</span> (from 4/24/1998) installed. The symptom is that although everything compiles just fine, however in the linking stage there are dozens of unresolved symbol errors for ODBC functions. Ask "pc.systems" to fix this for your PC.</p></li><li><p>On UNIX, it's only known to work with Merant's implementation of ODBC, and it has not been thoroughly tested or widely used, so surprises are possible.</p></li></ul></li></ul></div><div class="sec" id="ch_dbapi.mysql_driver"><h4><span class="title">MySQL Driver</span></h4><p><span class="nctnt highlight">Note:</span> This driver is not supported by SDBAPI.</p><p>There is a direct (without ODBC) MySQL driver in the NCBI C++ Toolkit DBAPI. However, the driver implements a very minimal functionality and does not support the following:</p><ul><li><p>Working with images by chunks (images can be accessed as string fields though)</p></li><li><p>RPC</p></li><li><p>BCP</p></li><li><p>SendData functionality</p></li><li><p>Connection pools</p></li><li><p>Parameter binding</p></li><li><p>Canceling results</p></li><li><p>ReadItem</p></li><li><p>IsAlive</p></li><li><p>Refresh functions</p></li><li><p>Setting timeouts</p></li></ul></div></div></div><div class="sec" id="ch_dbapi.Major_Features_of_th"><h2><span class="title">The BDB Wrapper</span></h2><p>NCBI created the "BDB" wrapper to simplify use of the open source <a href="http://www.oracle.com/us/products/database/berkeley-db/overview/index.html">Berkeley DB</a> library. Berkeley DB provides tools for the development of specialized data storage in applications not having access to a centralized RDBMS.</p><ul><li><p><b>C++ wrapper on top of Berkeley DB.</b> The BDB wrapper takes care of many of the ultra low-level details for C programmers using the Berkeley DB. BDB implements B-Tree file access (both keyed and sequential), environments, cursors, and transactions.</p></li><li><p><b>Error checking.</b> All error codes coming from the Berkeley DB are analyzed and processed in a manner common to all other components of the C++ Toolkit. When an error situation is detected, the BDB wrapper sends an exception that is reported by the diagnostic services and can be handled by the calling application, similar to any other Toolkit exception.</p></li><li><p><b>Support for relational table structure and different data types.</b> The Berkeley DB itself is “type agnostic” and provides no means to manipulate data types. But for many cases, clear data type support can save a lot of work. The Toolkit implements all major scalar data types so it can be used like a regular database.</p></li><li><p><b>Cross platform compatibility.</b> The BDB databases can be transferred across platforms without reconverting the data. The BDB tracks the fact that the database was created as big-endian or little-endian and does the conversion transparently when the database migrates.</p></li><li><p><b>Easy BLOBs.</b> The BDB wrapper supports keyed BLOB storage. BLOBs can be streamed to and from the database. A set of additional interfaces has been written to simplify the BLOB access in comparison with the original Berkeley DB C library.</p></li><li><p><b>Disk-based cache interface.</b> The BDB wrapper implements a cache disk cache service used by other Toolkit components to minimize client-server traffic and to store parts of the data locally. Different cache management and data expiration policies have been put in place.</p></li><li><p><b>Database maps.</b> The BDB wrapper includes template classes similar to STL map and multimap but persistently stores the map content in the Berkeley DB files.</p></li><li><p><b>Simple queries.</b> The BDB wrapper includes implementation of a simple query language to search records in flat files.</p></li></ul></div><div class="sec" id="ch_dbapi.The_SQLite_Wrapper"><h2><span class="title">The SQLite Wrapper</span></h2><p>The NCBI C++ Toolkit provides the "SQLite Wrapper" for the open source <a href="http://sqlite.org/">SQLite</a> library. Like Berkeley DB, SQLite is implemented as a library linked with the application, rather than a separate DBMS.</p><p>Some of the SQLite wrapper features are:</p><ul><li><p>A class, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSQLITE__Global.html">CSQLITE_Global</a>, with static functions for tuning SQLite as a whole as opposed to tuning connection-by-connection.</p></li><li><p>A convenience class, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSQLITE__Connection.html">CSQLITE_Connection</a>, for connecting to a database.</p></li><li><p>Convenience classes for working with prepared statements, blobs, and exceptions.</p></li></ul><p>Please see the <a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c%2B%2B/include/db/sqlite/sqlitewrapp.hpp?view=log">sqlitewrapp.hpp</a> header for API details.</p><p>For more information about SQLite, see the <a href="http://sqlite.org/docs.html">online SQLite documentation</a>.</p></div><div class="sec" id="ch_dbapi.Database_loadbalanci"><h2><span class="title">Database Load-Balancing (DBLB)</span></h2><p>Many server-based databases are load-balanced for efficient resource management. Accessing load-balanced databases is automatically done from C++ when using the <a href="ch_dbapi.html#ch_dbapi.SDBAPI_UserLayer_Reference">SDBAPI</a> library, but requires some specific statements in the client code when using the <a href="ch_dbapi.html#ch_dbapi.The_DBAPI_Library">DBAPI</a> library or <a href="ch_dbapi.html#ch_dbapi.Database_Access_via_Python_and">scripts</a>. This section discusses setting up and using load-balanced databases.</p><p>The following sections cover specific aspects of Database Load-Balancing:</p><ul><li><p><a href="ch_dbapi.html#ch_dbapi.Getting_started">Setting up Load-Balancing of Database Servers</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Using_Database_LoadBalancing_fr">Using Database Load-Balancing from C++</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Database_Access_via_Python_and">Load-Balanced Database Access via Python and Perl</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.Advantages_of_using_">Advantages of using DBLB</a></p></li><li><p><a href="ch_dbapi.html#ch_dbapi.HOW_IT_WORKS_by_defa">How it works (by default)</a></p></li></ul><div class="sec" id="ch_dbapi.Getting_started"><h3><span class="title">Setting up Load-Balancing of Database Servers</span></h3><p>For the following to be clear, it is important to distinguish between a database name, an underlying (actual) server name (e.g. MSSQL17), which hosts a variety of databases, a database server alias, and a service name. A server alias may be moved to a different underlying server. The server alias is often used with sqsh, and the GUI tools, such as SQL Management studio. The service name is used by the load-balancer to look up the underlying server to use, and is the name that should be used by an application. The server aliases and service names often share a common prefix and would look similar, and in fact for reasons presented below, there should be at least one server alias that is identical to the service name.</p><p>The following steps must be done prior to database load-balancing:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Ask the DBAs to add your service name (e.g. YOURSERVICE) to the load-balancer configuration database. Typically, the names are clear, for example, there are server aliases YOURSERVICE1, and YOURSERVICE2 that already exist, and databases that have “YOURSERVICE” as an embedded string, but if not, the databases providing the service and the server aliases involved should be given. Note that if databases are moved to different underlying servers, both the server aliases, and the load-balancer configuration which points to those servers are both moved, synchronously.</p></dd><dt>2</dt><dd><p class="no_top_margin">Tell the DBAs which of the server aliases point to the server that should be used, if the load-balancer is unavailable, as the DBAPI will look for a server alias with the same name as the service, in that case.</p></dd><dt>3</dt><dd><p class="no_top_margin">The DBAs will also ask for a DNS name to match the service name as a backup connection method, should everything else fail.</p></dd></dl></div><div class="sec" id="ch_dbapi.Using_Database_LoadBalancing_fr"><h3><span class="title">Using Database Load-Balancing from C++</span></h3><p>For simplest access, see the section on <a href="ch_dbapi.html#ch_dbapi.Simple_Database_Access_via_C">using SDBAPI</a> above. SDBAPI uses the database load-balancing by default, so no further steps are necessary.</p><p>If DBAPI is being used (e.g. if a feature that is only available in DBAPI is required), and you want to activate database load-balancing:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">Before the very first DBAPI connection attempt, call:<br /><br /><span class="nctnt ncbi-code">#include &lt;dbapi/driver/dbapi_svc_mapper.hpp&gt;</span><br /><span class="nctnt ncbi-code">DBLB_INSTALL_DEFAULT();</span><br /></p></dd><dt>2</dt><dd><p class="no_top_margin">Link <span class="nctnt ncbi-lib">'$(XCONNEXT)'</span> and <span class="nctnt ncbi-lib">'xconnect'</span> libraries to your application.</p></dd></dl><p>If steps (1) and (2) above are done then the DBAPI connection methods (such as <span class="nctnt ncbi-func">Connect()</span> or <span class="nctnt ncbi-func">ConnectValidated()</span>) will attempt to resolve the passed server name as a load-balanced service name.</p><p><span class="nctnt highlight">Note:</span> If steps (1) and (2) above are not done, or if DBLB library is not available (such as in the publicly distributed code base), or if the passed server name cannot be resolved as a load-balanced service name, then the regular database server name resolution will be used – i.e. the passed name will first be interpreted as a server alias (using the "interfaces" file), and if that fails, it will be interpreted as a DNS name. Note however that by default if the service name resolves (exists), then the regular database server name resolution will not be used as a fallback, even if DBAPI can't connect (for whatever reason) to the servers that the service resolves to.</p><p>Example:</p><pre><span class="nctnt-pre ncbi-code">#include &lt;dbapi/driver/dbapi_svc_mapper.hpp&gt;<br /><br />DBLB_INSTALL_DEFAULT();<br />IDataSource* ds = dm.CreateDs("ftds");<br />IConnection* conn = ds-&gt;CreateConnection();<br /><br />// Note: It is possible to connect by calling conn-&gt;Connect(), but it is<br />// recommended to use a validator here because, in conjunction with DBAPI's <br />// internal retry mechanism, a validator helps DBAPI select a good server from a<br />// load-balanced set when the actual database is temporarily unavailable on one<br />// (or more) of the servers.<br />CTrivialConnValidator my_validator(my_databasename);<br />conn-&gt;ConnectValidated(<br />    my_validator, my_username, my_password, my_servicename, my_ databasename);</span></pre></div><div class="sec" id="ch_dbapi.Database_Access_via_Python_and"><h3><span class="title">Load-Balanced Database Access via Python and Perl</span></h3><p>There is a Unix command-line tool, <span class="nctnt ncbi-app">ncbi_dblb_cli</span>, that you can call from your script to perform service resolution and connection validation - i.e. to find a load-balanced server that is online and that supports a given service and database.</p><p>From Python:</p><pre><span class="nctnt-pre ncbi-code">#!/bin/env python<br /><br />import subprocess, sys<br /><br />cmdline = [<br />    "/opt/machine/lbsm/bin/ncbi_dblb_cli",<br />    "lookup",<br />    "-service",<br />    "DBAPI_MS_TEST",<br />    "-database",<br />    "DBAPI_Sample",<br />]<br />result = subprocess.Popen(cmdline, stdout=subprocess.PIPE).communicate()[0]<br /># A successful result will match a line beginning with a name followed by a tab.<br />if result:<br />    server = result.strip().split("\t")[0]<br />    # Do whatever is needed with the server name...</span></pre><p>From Perl:</p><pre><span class="nctnt-pre ncbi-code">#!/bin/env perl<br /><br />use strict;<br /><br />my $cmd = '/opt/machine/lbsm/bin/ncbi_dblb_cli';<br />my $svc = 'DBAPI_MS_TEST';<br />my $db  = 'DBAPI_Sample';<br />my $cmdline = $cmd . ' lookup -service ' . $svc . ' -database ' . $db;<br /># A successful result will match a line beginning with a name followed by a tab.<br />if(`$cmdline` =~ m/^([^\t]+)/) {<br />    my $server = $1;<br />    # Do whatever is needed with the server name...<br />}</span></pre><p>If you don't need to ensure that the server is online or check for a specific database, you can just call <span class="nctnt ncbi-app">ncbi_dblb</span>.</p><p>From Python:</p><pre><span class="nctnt-pre ncbi-code">#!/bin/env python<br /><br />import subprocess, sys<br /><br />if len(sys.argv) &gt; 1:<br />    # Use the -q option to fetch only the server name.<br />    cmd = ['/opt/machine/lbsm/bin/ncbi_dblb', '-q', sys.argv[1]]<br />    srv = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0].strip()<br />    # Do whatever is needed with the server name...</span></pre><p>From Perl:</p><pre><span class="nctnt-pre ncbi-code">#!/bin/env perl<br /><br />use strict;<br /><br />if (@ARGV) {<br />    # Use the -q option to fetch only the server name.<br />    my $cmd = '/opt/machine/lbsm/bin/ncbi_dblb -q ' . $ARGV[0];<br />    my $srv = `$cmd`;<br />    chomp($srv);<br />    # Do whatever is needed with the server name...<br />}</span></pre><p>There is also a Python module that provides an interface to the load-balancing service:</p><ul><li><p>code: <a href="https://stash.ncbi.nlm.nih.gov/projects/LBSMD/repos/pylbsmd/browse">https://stash.ncbi.nlm.nih.gov/projects/LBSMD/repos/pylbsmd/browse</a></p></li><li><p>documentation: <a href="https://dsubmit.ncbi.nlm.nih.gov/docs/lbsmd/">https://dsubmit.ncbi.nlm.nih.gov/docs/lbsmd/</a></p></li></ul></div><div class="sec" id="ch_dbapi.Advantages_of_using_"><h3><span class="title">Advantages of using DBLB</span></h3><div class="sec" id="ch_dbapi.C_Specific"><h4><span class="title">C++ Specific</span></h4><ul><li><p>A database-level verification mechanism.</p></li><li><p>Latch onto the same database server for the life of your process. It's often useful to avoid possible inter-server data discrepancy. The "latch-on" mechanism can be relaxed or turned off if needed.</p></li><li><p>Automatic connection retries. If a connection to the selected server cannot be established, the API will try again with other servers (unless it is against the chosen "latch-on" strategy).</p></li><li><p>The default connection strategy is *configurable*. You can change its parameters using a configuration file, environment variables, and/or programmatically. You can also configure locally for your application ad-hoc mappings to the database servers (this is usually not recommended but can come in handy in emergency cases or for debugging).</p></li><li><p>If needed, you can implement your own customized mapper. Components of the default connection strategy can be used separately, or in combination with each other and with the user-created strategies, if necessary.</p></li></ul></div><div class="sec" id="ch_dbapi.General"><h4><span class="title">General</span></h4><ul><li><p>Connecting to the database servers by server name and/or "interfaces" file based aliases still works the same as it used to.</p></li><li><p>Automatic avoidance of unresponsive database servers. This prevents your application from hanging for up to 30 seconds on the network timeout.</p></li><li><p>Independence from the database "interfaces" file. A centrally maintained service directory is used instead, which is accessible locally and/or via network. It also dynamically checks database servers' availability and excludes unresponsive servers.</p></li></ul></div></div><div class="sec" id="ch_dbapi.HOW_IT_WORKS_by_defa"><h3><span class="title">How it works (by default)</span></h3><p>The following steps are performed each time a request is made to establish a load-balanced connection to a named database service:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">The requests will first go through the DBLB mechanism that tries to match the requested service name against the services known to the NCBI <a href="ch_app.html#ch_app.Load_Balancing">Load Balancer</a> and/or those described in the application's configuration file.</p></dd><dt>2</dt><dd><p class="no_top_margin">If the requested service name is unknown to the load balancer then this name will be used "as is".</p></dd><dt>3</dt><dd><p class="no_top_margin">However, if this service name is known to the DBLB then the DBLB will try to establish a connection to the database server that it deems the most suitable. If the service is handled by the NCBI load-balancer, then the unresponsive servers will be weeded out, and a load on the machines that run the servers may be taken into account too.</p></dd><dt>4</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> If the connection cannot be established, then DBLB will automatically retry the connection, now using another suitable database server.</p></dd><dt>5</dt><dd><p class="no_top_margin">This procedure may be repeated several times, during which there will be only one attempt to connect to each database.</p></dd><dt>6</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> Once a database connection is successfully established it will be "latched-on". This means that when you will try to connect to the same service or alias within the same application again then you will be connected to the same database server (this can be relaxed or turned off completely).</p></dd><dt>7</dt><dd><p class="no_top_margin">For example, you can connect to the "PMC" service which is currently mapped to two servers. The server names are provided dynamically by the NCBI load-balancer, so you never have to change your configuration or recompile your application if either a service configuration or an "interfaces" file get changed.</p></dd><dt>8</dt><dd><p class="no_top_margin"><span class="nctnt highlight">C++ only:</span> If <span class="nctnt ncbi-func">ConnectValidated()</span> is used to connect to a database, then requests to establish database connections will first go through the server-level load-balancing mechanism. On successful login to server, the database connection will be validated against the validator. If the validator does not "approve" the connection, then DBAPI will automatically close this connection and repeat this login/validate attempt with the next server, and so on, until a "good" (successful login + successful validation) connection is found. If you want to validate a connection against more than one validator/database, then you can combine validators. Class <span class="nctnt ncbi-class">CConnValidatorCoR</span> was developed to allow combining of other validators into a chain.</p></dd></dl></div></div></div></div><div id="tkb_internal" class="col four_col last"><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" id="source-branding"><div class="iconblock clearfix ten_col"><a class="img_link icnblk_img" title="Table of Contents Page" target="mainwindow" href="toc.html"><img class="source-thumb" src="img/th-toolkit-lrg.png" alt="Cover of The NCBI C++ Toolkit Book" height="100px" width="80px" /></a><div class="icnblk_cntnt"><div class="_bk_pgbnr_cit"><div class="_bk_pgbnr_cit_ln">The NCBI C++ Toolkit Book [Internet].</div><div class="_bk_pgbnr_cit_ln">Vakatov D, editor.</div><div class="_bk_pgbnr_cit_ln">Bethesda (MD): <a href="http://www.ncbi.nlm.nih.gov/">National Center for Biotechnology Information (US)</a>; 2004-.</div></div></div></div></div><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" class="half_rhythm"><ul class="inline_list"><li><a href="toc.html">Table of Contents Page</a></li><li> | </li><li><a class="jig-ncbidialog" data-jigconfig="width:400 , modal:true" href="#citation-window">Cite this Page</a><div class="jig-ncbidialog-box" style="display:none" title="Cite this Page" id="citation-window"><div class="bk_tt">
        Vakatov D, editor. The NCBI C++ Toolkit Book [Internet]. Bethesda (MD): National Center for Biotechnology Information (US); 2004-.  10, Database Access Support
                    . 
        [Updated: April 2, 2015]
    .

                            <div class="bk_tt"><span class="bk_cite_avail">Available from: http://www.ncbi.nlm.nih.gov/toolkit/doc/book/ch_dbapi</span></div></div><span class="bk_cite_avail"></span></div></li></ul></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">In this page</div></div><div class="portlet_content"><ul><li><a href="#ch_dbapi.Security">Security</a></li><li><a href="#ch_dbapi.SDBAPI__DBAPI_Feature_Compariso">SDBAPI / DBAPI Feature Comparison</a></li><li><a href="#ch_dbapi.SDBAPI_UserLayer_Reference">The SDBAPI Library</a></li><li><a href="#ch_dbapi.The_DBAPI_Library">The DBAPI Library</a></li><li><a href="#ch_dbapi.Major_Features_of_th">The BDB Wrapper</a></li><li><a href="#ch_dbapi.The_SQLite_Wrapper">The SQLite Wrapper</a></li><li><a href="#ch_dbapi.Database_loadbalanci">Database Load-Balancing (DBLB)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Search</div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />  					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Source Browsers</div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> LXR: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Doxygen: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">SVN Source Repository</div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> Documentation: </span><a href="ch_getcode_svn.html#ch_getcode_svn.code_retrieval">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="ch_getcode_svn.html#ch_getcode_svn.external">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (dev): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (extra): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (prod): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Resources</div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Wiki</a></li><li class="internal-only"><a href="https://jira.ncbi.nlm.nih.gov/browse/CXX" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">JIRA</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="http://intranet/ieb/ToolBox/GRID/dashboard/">GRID Dashboard</a></li><li><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/SC/index.html">Stable Components</a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download the Toolkit</a></li><li><a href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:cpp-doc@ncbi.nlm.nih.gov" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div><div id="tkb_public" class="col four_col last"><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" id="source-branding"><div class="iconblock clearfix ten_col"><a class="img_link icnblk_img" title="Table of Contents Page" target="mainwindow" href="toc.html"><img class="source-thumb" src="img/th-toolkit-lrg.png" alt="Cover of The NCBI C++ Toolkit Book" height="100px" width="80px" /></a><div class="icnblk_cntnt"><div class="_bk_pgbnr_cit"><div class="_bk_pgbnr_cit_ln">The NCBI C++ Toolkit Book [Internet].</div><div class="_bk_pgbnr_cit_ln">Vakatov D, editor.</div><div class="_bk_pgbnr_cit_ln">Bethesda (MD): <a href="http://www.ncbi.nlm.nih.gov/">National Center for Biotechnology Information (US)</a>; 2004-.</div></div></div></div></div><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" class="half_rhythm"><ul class="inline_list"><li><a href="toc.html">Table of Contents Page</a></li><li> | </li><li><a class="jig-ncbidialog" data-jigconfig="width:400 , modal:true" href="#citation-window">Cite this Page</a><div class="jig-ncbidialog-box" style="display:none" title="Cite this Page" id="citation-window"><div class="bk_tt">
        Vakatov D, editor. The NCBI C++ Toolkit Book [Internet]. Bethesda (MD): National Center for Biotechnology Information (US); 2004-.  10, Database Access Support
                    . 
        [Updated: April 2, 2015]
    .

                            <div class="bk_tt"><span class="bk_cite_avail">Available from: http://www.ncbi.nlm.nih.gov/toolkit/doc/book/ch_dbapi</span></div></div><span class="bk_cite_avail"></span></div></li></ul></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">In this page</div></div><div class="portlet_content"><ul><li><a href="#ch_dbapi.Security">Security</a></li><li><a href="#ch_dbapi.SDBAPI__DBAPI_Feature_Compariso">SDBAPI / DBAPI Feature Comparison</a></li><li><a href="#ch_dbapi.SDBAPI_UserLayer_Reference">The SDBAPI Library</a></li><li><a href="#ch_dbapi.The_DBAPI_Library">The DBAPI Library</a></li><li><a href="#ch_dbapi.Major_Features_of_th">The BDB Wrapper</a></li><li><a href="#ch_dbapi.The_SQLite_Wrapper">The SQLite Wrapper</a></li><li><a href="#ch_dbapi.Database_loadbalanci">Database Load-Balancing (DBLB)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Search</div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />  					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr><td colspan="2"><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td></tr><tr><td colspan="2"><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td colspan="2"><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Source Browsers</div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">SVN Source Repository</div></div><div class="portlet_content"><ul><li class="external-only"><a href="ch_getcode_svn.html#ch_getcode_svn.external">Documentation</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Web (dev)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Resources</div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download the Toolkit</a></li><li><a href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:cpp-doc@ncbi.nlm.nih.gov" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
