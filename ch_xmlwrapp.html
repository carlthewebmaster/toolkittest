<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>XmlWrapp (XML parsing and handling, XSLT, XPath) - The NCBI C++ Toolkit Book [Internet] - NCBI</title><meta name="description" content="A comprehensive manual on the NCBI C++ toolkit, including its design and development framework, a C++ library reference, software examples and demos, FAQs and release notes." /><meta name="robots" content="index,nofollow,noarchive" /><meta name="page_id" content="ch_xmlwrapp" /><meta name="page_type" content="chapter" /><meta name="ncbipopper" content="triggerPosition:'bottom left',destPosition:'top left',openEvent:'click',closeEvent:'click'" /><script type="text/javascript" src="http://www.ncbi.nlm.nih.gov/core/jig/1.13.1/js/jig.min.js "></script><link type="text/css" rel="stylesheet" href="css/ptbooks.css" /><link type="text/css" rel="stylesheet" href="css/toolkit.css" /></head><body><div class="grid no_max_width"><div class="col twelve_col nomargin shadow"><div class="content"><div class="col eight_col"><div class="nvgtn"><a href="#__nav_cntnt" class="jig-ncbipopper">Contents â–¾</a><div style="display:none;width:700px;height:500px;overflow:auto;" id="__nav_cntnt"><a class="right" href="toc.html">Table of Contents Page</a><ul class="simple-list"><li class="half_rhythm"><a href="toolkit.fm.html">Book Information</a></li><li class="half_rhythm"><a href="part1.html">Part 1. Overview</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_intro.html">1. Introduction to the C++ Toolkit</a></li><li class="half_rhythm"><a href="ch_start.html">2. Getting Started</a></li></ul></li><li class="half_rhythm"><a href="part2.html">Part 2. Development Framework</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_getcode_svn.html">3. Retrieve the Source Code (FTP and Subversion)</a></li><li class="half_rhythm"><a href="ch_config.html">4. Configure, Build, and Use the Toolkit</a></li><li class="half_rhythm"><a href="ch_build.html">5. Working with Makefiles</a></li><li class="half_rhythm"><a href="ch_proj.html">6. Project Creation and Management</a></li><li class="half_rhythm"><a href="ch_style.html">7. Programming Policies and Guidelines</a></li></ul></li><li class="half_rhythm"><a href="part3.html">Part 3. C++ Toolkit Library Reference</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_core.html">8. Portability, Core Functionality and Application Framework</a></li><li class="half_rhythm"><a href="ch_conn.html">9. Networking and IPC</a></li><li class="half_rhythm"><a href="ch_dbapi.html">10. Database Access Support</a></li><li class="half_rhythm"><a href="ch_cgi.html">11. CGI and Fast-CGI </a></li><li class="half_rhythm"><a href="ch_html.html">12. HTML</a></li><li class="half_rhythm"><a href="ch_ser.html">13. Data Serialization (ASN.1, XML)</a></li><li class="half_rhythm"><a href="ch_datamod.html">14. Biological Sequence Data Model</a></li><li class="half_rhythm"><a href="ch_objmgr.html">15. Biological Object Manager</a></li><li class="half_rhythm"><a href="ch_blast.html">16. BLAST API</a></li><li class="half_rhythm"><a href="ch_dataaccess.html">17. Access to NCBI data</a></li><li class="half_rhythm"><a href="ch_algoalign.html">18. Biological Sequence Alignment</a></li><li class="half_rhythm"><a href="ch_gui.html">19. GUI and Graphics</a></li><li class="half_rhythm"><a href="ch_boost.html">20. Using the Boost Unit Test Framework</a></li></ul></li><li class="half_rhythm"><a href="part4.html">Part 4. Wrappers for 3rd-Party Packages</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_xmlwrapp.html">21. XmlWrapp (XML parsing and handling, XSLT, XPath)</a></li></ul></li><li class="half_rhythm"><a href="part5.html">Part 5. Software</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_debug.html">22. Debugging, Exceptions, and Error Handling</a></li><li class="half_rhythm"><a href="ch_grid.html">23. Distributed Computing</a></li><li class="half_rhythm"><a href="ch_app.html">24. Applications</a></li><li class="half_rhythm"><a href="ch_demo.html">25. Examples and Demos</a></li><li class="half_rhythm"><a href="ch_res.html">26. C Toolkit Resources for C++ Toolkit Users</a></li></ul></li><li class="half_rhythm"><a href="part6.html">Part 6. Help and Support</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_browse.html">27. NCBI C++ Toolkit Source Browser</a></li><li class="half_rhythm"><a href="ch_devtools.html">28. Software Development Tools</a></li><li class="half_rhythm"><a href="ch_faq.html">29. FAQs, Useful Documentation Links, and Mailing Lists</a></li></ul></li><li class="half_rhythm"><a href="part7.html">Part 7. Library and Applications Configuration</a><ul class="simple-list"><li class="half_rhythm"><a href="ch_libconfig.html">30. Library Configuration</a></li></ul></li><li class="half_rhythm"><a href="part8.html">Release Notes</a></li><li class="half_rhythm"><a href="app1.appendix1.html">Appendix - Books and Styles</a></li></ul></div><div class="pagination"><a class="pagelink active prev" title="Previous page" href="part4.html">&lt; Prev</a><a class="pagelink active next" title="Next page" href="part5.html">Next &gt;</a></div><div class="pdf-link"><a class="print-link" title="PDF version of this page" href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/ch_xmlwrapp.pdf">PDF</a></div></div><div class="meta_content"><h1><span class="label">21</span><span class="title">XmlWrapp (XML parsing and handling, XSLT, XPath)</span></h1><p class="small">Created: August 2, 2009; Last Update: November 7, 2014.</p></div><div class="body-content jig-ncbiinpagenav" data-jigconfig="allHeadingLevels: ['h2'],smoothScroll: false"><div class="sec"><h2><span class="title">Overview</span></h2><div class="sec"><h3><span class="title">Introduction</span></h3><p>The NCBI C++ Toolkit has forked and enhanced the open-source <a href="http://vslavik.github.io/xmlwrapp/">xmlwrapp</a> project, which provides a simplified way for developers to work with XML. This chapter discusses the NCBI fork and how to use it. This chapter refers to NCBI's project as "XmlWrapp" and the open-source project as "xmlwrapp". Both projects produce a library named <span class="nctnt ncbi-lib">libxmlwrapp</span>.</p></div><div class="sec"><h3><span class="title">Chapter Outline</span></h3><p>The following is an outline of the topics presented in this chapter:</p><ul><li><p><a href="#ch_xmlwrapp.General_Information">General Information</a></p></li><li><p><a href="#ch_xmlwrapp.XmlWrapp_Classes">XmlWrapp Classes</a></p></li><li><p><a href="#ch_xmlwrapp.How_To">How To</a></p><ul><li><p><a href="#ch_xmlwrapp._Create_a_Document_fr">Create a Document from an std::string Object</a></p></li><li><p><a href="#ch_xmlwrapp._Create_a_Document_fr_1">Create a Document from a File</a></p></li><li><p><a href="#ch_xmlwrapp.Save_a_Document_to_a">Save a Document or Node to a File</a></p></li><li><p><a href="#ch_xmlwrapp.Iterate_Over_Nodes">Iterate Over Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Insert_and_Remove_No">Insert and Remove Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Iterate_Over_Attribu">Iterate Over Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Insert_and_Remove_At">Insert and Remove Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Work_with_XML_Namesp">Work with XML Namespaces</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_Event_Parser">Use an Event Parser</a></p></li><li><p><a href="#ch_xmlwrapp.Make_an_XSLT_Transfo">Make an XSLT Transformation</a></p></li><li><p><a href="#ch_xmlwrapp.Run_an_XPath_Query">Run an XPath Query</a></p></li><li><p><a href="#ch_xmlwrapp.Run_an_XPath_Query_with_a_De">Run an XPath Query with a Default Namespace</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_Extension_Function">Use an Extension Function</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_Extension_Element">Use an Extension Element</a></p></li><li><p><a href="#ch_xmlwrapp.Use_an_XML_Catalog">Use an XML Catalog</a></p></li></ul></li><li><p><a href="#ch_xmlwrapp.Warning_Collaborative_Use_of">Warning: Collaborative Use of XmlWrapp and libxml2</a></p></li><li><p><a href="#ch_xmlwrapp.Implementation_Details">Implementation Details</a></p><ul><li><p><a href="#ch_xmlwrapp.Copying_and_Referencing_Node">Copying and Referencing Nodes</a></p></li><li><p><a href="#ch_xmlwrapp.Using_Namespaces_with_XPath">XPath Expressions and Namespaces</a></p></li><li><p><a href="#ch_xmlwrapp.Containers_of_Attributes__It">Containers of Attributes - Iteration and Size</a></p></li><li><p><a href="#ch_xmlwrapp.Changing_Default_Attributes">Changing Default Attributes</a></p></li><li><p><a href="#ch_xmlwrapp.Event_Parser_and_Named_Entit">Event Parser and Named Entities</a></p></li><li><p><a href="#ch_xmlwrapp.Safe_and_Unsafe_Namespaces">Safe and Unsafe Namespaces</a></p></li><li><p><a href="#ch_xmlwrapp.Thread_Safety">Thread Safety</a></p></li><li><p><a href="#ch_xmlwrapp.Safe_libxml2_and_libxslt_Cle">Safe libxml2 and libxslt Cleanup</a></p></li><li><p><a href="#ch_xmlwrapp.Formatting_of_Programmatical">Formatting of Programmatically Added Content</a></p></li></ul></li><li><p><a href="#ch_xmlwrapp.FAQ">FAQ</a></p></li></ul></div></div><div class="sec" id="ch_xmlwrapp.General_Information"><h2><span class="title">General Information</span></h2><p>Both NCBI's XmlWrapp project and the open-source <a href="http://vslavik.github.io/xmlwrapp/">xmlwrapp</a> project produce the <span class="nctnt ncbi-lib">libxmlwrapp</span> library which is a generic XML handling C++ library built on top of widespread <a href="http://xmlsoft.org/">libxml2</a> / <a href="http://xmlsoft.org/XSLT/">libxslt</a> C libraries. The main features of <span class="nctnt ncbi-lib">libxmlwrapp</span> are:</p><ul><li><p>Tree parser (DOM)</p></li><li><p>Event parser (SAX)</p></li><li><p>Creation / removal of nodes, attributes and documents</p></li><li><p>Searching nodes and attributes</p></li><li><p>XSLT transformation support</p></li><li><p>DTD validation support</p></li><li><p>XML catalog support</p></li></ul><p>XmlWrapp was created by forking <a href="http://vslavik.github.io/xmlwrapp/">xmlwrapp</a> and making these enhancements:</p><ul><li><p>Adding support for XPath.</p></li><li><p>Implementing full-featured XML namespace support for both nodes and attributes.</p></li><li><p>Adding XSD validation support.</p></li><li><p>Extending the functionality of some existing classes.</p></li><li><p>Adapting the demo code and test cases to work within the NCBI framework.</p></li><li><p>Adding support for XSLT extension functions and extension elements.</p></li><li><p>Adding the ability to transparently work with default attributes.</p></li><li><p>Fixing some bugs that were in <a href="http://vslavik.github.io/xmlwrapp/">xmlwrapp</a>.</p></li></ul><p>The figure below illustrates the relationship between your C++ application and the XML libraries:</p><p><span><a href="img/Overview.png" class="img_link" target="_blank" title="Click to see the full-resolution image"><img src="img/Overview.png" alt="Image Overview.png" /></a></span></p><p>One goal of the <span class="nctnt ncbi-lib">libxmlwrapp</span> library is to be a very thin wrapper around <span class="nctnt ncbi-lib">libxml2</span> / <span class="nctnt ncbi-lib">libxslt</span> and to provide a simple yet powerful C++ interface without compromising speed. To achieve this goal, the library does not implement expensive run-time validity checks, and it is possible to write compilable C++ code that will cause a segmentation fault. For example, it is possible to create an unsafe XmlWrapp namespace object that points to an existing <span class="nctnt ncbi-lib">libxml2</span> namespace, then destroy the pointed-to namespace. This results in the unsafe <span class="nctnt ncbi-lib">libxmlwrapp</span> namespace object containing a dangling pointer. Subsequent access of the pointer will cause an exception or abnormal termination.</p><p>The original open-source <a href="http://vslavik.github.io/xmlwrapp/">libxmlwrapp</a> 0.6.0 was extended and modified to fit the NCBI C++ Toolkit build framework and API functionality requirements. Later, the functional changes introduced in 0.6.1 and 0.6.2 were patched into the NCBI code. Specific enhancements that NCBI incorporated into XmlWrapp include:</p><ul><li><p>XPath support:</p><ul><li><p>XPath queries can be run based on XPath expressions. The queries return node sets which can be iterated.</p></li></ul></li><li><p>A new class, <span class="nctnt ncbi-class">xml::schema</span>, was added for XSD support.</p></li><li><p>Implementing a full-featured XML namespace class, <span class="nctnt ncbi-class">xml::ns</span>, for use by both nodes and attributes, with these features:</p><ul><li><p>Each node and attribute may be assigned to a namespace, or have their assignment removed. The assigned namespace can be retrieved.</p></li><li><p>Each node and attribute may contain a list of namespace definitions. Namespace definitions can be added to or removed from this list. The list can be retrieved.</p></li><li><p>XmlWrapp namespace objects can be either safe or unsafe. Safe namespace objects prevent program crashes by eliminating potentially invalid pointers. Using unsafe namespace objects requires less time and memory, but may result in invalid pointers and may cause a crash. See the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Safe_and_Unsafe_Namespaces">safe and unsafe namespaces</a> section for more details.</p></li><li><p>Nodes and attributes can now be searched by namespace as well as by name.</p></li></ul></li><li><p>Error handling was enhanced (or added) for tree and event parsing, and for DTD and XSD validation. Previously, only the last message was retained and processing stopped on the first error. Now all messages are retained and processing only stops if a fatal error is encountered.</p></li><li><p>Adapting the demo code and test cases to work within the NCBI framework.</p></li><li><p>Fixing some bugs that were in <span class="nctnt ncbi-lib">libxmlwrapp</span>:</p><ul><li><p><span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 did not copy the namespace when it copied an attribute. When XmlWrapp copies an attribute, it also copies the assigned namespace and all namespace definitions contained by the attribute.</p></li><li><p>The Sun WorkShop compiler failed to compile <span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 because it was missing a definition for the STL distance algorithm. XmlWrapp conditionally defines this template for this compiler.</p></li><li><p>The XML parser in <span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 failed to detect a certain form of mal-formed document. NCBI found and fixed this bug. The patch was submitted to the <span class="nctnt ncbi-lib">libxmlwrapp</span> project and was accepted.</p></li><li><p>In <span class="nctnt ncbi-lib">libxmlwrapp</span> 0.6.0 it was possible that using a reference to a node that was created by dereferencing an iterator could cause a core dump or unexpected data if the iterator was used after the reference was created.</p></li></ul></li></ul><p>The NCBI enhancements retain the generic nature of <span class="nctnt ncbi-lib">libxmlwrapp</span>, and are not tailored to any particular application domain.</p><p>XmlWrapp demo <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/demo/misc/xmlwrapp">applications</a> and <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp">unit tests</a> are available inside NCBI, but the most common and basic usage examples are given in the <a href="ch_xmlwrapp.html#ch_xmlwrapp.How_To">next section</a>.</p><p>All the XmlWrapp functionality resides in the C++ namespaces <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexml.html">xml::</a> and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexslt.html">xslt::</a>, and all the code is Doxygen-style commented.</p></div><div class="sec" id="ch_xmlwrapp.XmlWrapp_Classes"><h2><span class="title">XmlWrapp Classes</span></h2><p><span><a href="img/ch_xmlwrapp_classes.png" class="img_link" target="_blank" title="Click to see the full-resolution image"><img src="img/ch_xmlwrapp_classes.png" alt="Image ch_xmlwrapp_classes.png" /></a></span></p><p>The figure above shows the most important classes in XmlWrapp. XML can be parsed from a file, memory buffer, or stream, creating a document object. One of the most important things you can get from the document object is the document root node.</p><p>Several classes in the figure are marked with the small "circled-i" symbol in the corner. This mark means that the class supports iterators and const iterators. The node class is a container of other nodes and you can iterate over immediate node children similar to how you do with STL containers.</p><p>A node may have an XML namespace and also may define namespaces. To support this, XmlWrapp provides the XML namespace class, <span class="nctnt ncbi-class">xml::ns</span>.</p><p>An XML node may have attributes as well, so XmlWrapp provides the <span class="nctnt ncbi-class">xml::attributes</span> class. This class is a container of attributes so both const and non-const iterators are provided.</p><p>The XPath support includes the <span class="nctnt ncbi-class">xml::xpath_expression</span> and <span class="nctnt ncbi-class">xml::node_set</span> classes. <span class="nctnt ncbi-class">xpath_expression</span> objects hold a single expression. <span class="nctnt ncbi-class">node_set</span> objects are created as the result of executing an XPath query for a given node. The <span class="nctnt ncbi-class">node_set</span> class is a container so it supports iterators.</p><p>To support XSD schema validation and DTD validation, XmlWrapp provides the <span class="nctnt ncbi-class">xml::schema</span> and <span class="nctnt ncbi-class">xml::dtd</span> classes. These classes work together with the <span class="nctnt ncbi-class">xml::document</span> class.</p><p>Warnings, errors and fatal errors may occur during the parsing and validating. To collect them, XmlWrapp provides the <span class="nctnt ncbi-class">xml::error_messages</span> class. The <span class="nctnt ncbi-class">error_messages</span> class includes the <span class="nctnt ncbi-func">print()</span> method, which returns a string containing a newline-separated list of messages. It also includes the <span class="nctnt ncbi-func">has_warnings()</span>, <span class="nctnt ncbi-func">has_errors()</span>, and <span class="nctnt ncbi-func">has_fatal_errors()</span> methods in case you are interested in the presence of a specific type of message. Note that errors and fatal errors are considered separately, so <span class="nctnt ncbi-func">has_fatal_errors()</span> may return <span class="nctnt ncbi-code">true</span> while <span class="nctnt ncbi-func">has_errors()</span> returns <span class="nctnt ncbi-code">false</span>.</p></div><div class="sec" id="ch_xmlwrapp.How_To"><h2><span class="title">How To</span></h2><p>This section includes compact code fragments that show the essence of how to achieve typical goals using XmlWrapp. The examples do not illustrate all the features of XmlWrapp and are not intended to be complete and compilable. Your code will need to include the necessary headers, use try-catch blocks, check for errors, and validate the XML document.</p><div class="sec" id="ch_xmlwrapp._Create_a_Document_fr"><h3><span class="title">Create a Document from an std::string Object</span></h3><pre><span class="nctnt-pre ncbi-code">std::string         xmldata( "&lt;TagA&gt;"<br />                                 "&lt;TagB&gt;stuff&lt;/TagB&gt;"<br />                             "&lt;/TagA&gt;" );<br />xml::document       doc( xmldata.c_str(), xmldata.size(), NULL );</span></pre></div><div class="sec" id="ch_xmlwrapp._Create_a_Document_fr_1"><h3><span class="title">Create a Document from a File</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "MyFile.xml", NULL );</span></pre><p><span class="nctnt highlight">Note:</span> The second parameter above is a pointer to an <span class="nctnt ncbi-class">error_messages</span> object, which stores any messages collected while parsing the XML document (a <span class="nctnt ncbi-code">NULL</span> value can be passed if you're not interested in collecting error messages). For example:</p><pre><span class="nctnt-pre ncbi-code">xml::error_messages msgs;<br />xml::document       doc( "MyFile.xml", &amp;msgs );<br />std:cout &lt;&lt; msgs.print() &lt;&lt; std:endl;</span></pre></div><div class="sec" id="ch_xmlwrapp.Save_a_Document_to_a"><h3><span class="title">Save a Document or Node to a File</span></h3><p>The simplest way is inserting into a stream:</p><pre><span class="nctnt-pre ncbi-code">// save document<br />xml::document       xmldoc( "abook" );  // "abook" is the root node<br />std::ofstream       f( "doc_file.xml" );<br /><br />f &lt;&lt; xmldoc;<br />f.close();<br /><br />// save node<br />xml::node           n( "the_one" );<br />std::ofstream       node_file( "node_file.xml" );<br /><br />node_file &lt;&lt; n &lt;&lt; std::endl;<br />f.close();</span></pre><p>The simplest way provides no control on how the output is formatted, but there is an alternative set of functions that accept formatting flags:</p><pre><span class="nctnt-pre ncbi-code">xml::document::save_to_string(...)<br />xml::document::save_to_stream(...)<br />xml::document::save_to_file(...)<br />xml::node::node_to_string(...)</span></pre><p>For example, if you do not want to have the XML declaration at the beginning of the document then you might have code similar to:</p><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "example.xml", NULL );<br />std::string         s;<br /><br />doc.save_to_string( s, xml::save_op_no_decl );</span></pre><p>Note that all the <span class="nctnt ncbi-func">save_to_*()</span> functions use the same underlying formatting code and therefore respond to flags in the same way.</p><p>For further discussion, see the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Formatting_of_Programmatical">Formatting of Programmatically Added Content</a> section. For a complete list of available formatting flags, see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/namespacexml.html#8599801d006476631c27a732819b9995"><tt>enum xml::save_options</tt></a>.</p></div><div class="sec" id="ch_xmlwrapp.Iterate_Over_Nodes"><h3><span class="title">Iterate Over Nodes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "MyFile.xml", NULL );<br />xml::node &amp;         root = doc.get_root_node();<br /><br />xml::node::const_iterator   child( root.begin() );<br />xml::node::const_iterator   child_end( root.end() );<br /><br />std::cout &lt;&lt; "root node is '" &lt;&lt; root.get_name() &lt;&lt; "'\n";<br />for ( ; child != child_end; ++child ) <br />{<br />    if ( child-&gt;is_text() ) continue;<br />    std::cout &lt;&lt; "child node '" &lt;&lt; child-&gt;get_name() &lt;&lt; "'" &lt;&lt; std:endl;<br />}</span></pre></div><div class="sec" id="ch_xmlwrapp.Insert_and_Remove_No"><h3><span class="title">Insert and Remove Nodes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile2.xml", NULL );<br />xml::node &amp;             root = doc.get_root_node();<br />xml::node::iterator     i = root.find( "insert_before", root.begin() );<br /><br />root.insert( i, xml::node("inserted") );<br />i = root.find( "to_remove", root.begin() );<br />root.erase( i );</span></pre></div><div class="sec" id="ch_xmlwrapp.Iterate_Over_Attribu"><h3><span class="title">Iterate Over Attributes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document              doc( "MyFile.xml", NULL );<br />const xml::attributes &amp;    attrs = doc.get_root_node().get_attributes();<br /><br />xml::attributes::const_iterator   i = attrs.begin();<br />xml::attributes::const_iterator   end = attrs.end();<br /><br />for ( ; i!=end; ++i )<br />{<br />    std::cout &lt;&lt; i-&gt;get_name() &lt;&lt; "=" &lt;&lt; i-&gt;get_value() &lt;&lt; std:endl;<br />}</span></pre></div><div class="sec" id="ch_xmlwrapp.Insert_and_Remove_At"><h3><span class="title">Insert and Remove Attributes</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile.xml", NULL );<br />xml::attributes &amp;       attrs = doc.get_root_node().get_attributes();<br /><br />attrs.insert( "myAttr", "attrValue" );<br />xml::attributes::iterator i = attrs.find( "attrToRemove" );<br />attrs.erase( i );</span></pre></div><div class="sec" id="ch_xmlwrapp.Work_with_XML_Namesp"><h3><span class="title">Work with XML Namespaces</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document           doc( "MyFile.xml", NULL );<br />xml::node &amp;             root = doc.get_root_node();<br />xml::ns                 rootSpace( root.get_namespace() );<br /><br />std::cout &lt;&lt; "Root namespace: " &lt;&lt; rootSpace.get_prefix() &lt;&lt; "-&gt;"<br />          &lt;&lt; rootSpace.get_uri() &lt;&lt; std:endl;<br /><br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   attr( attrs.find( "firstAttr" ) );<br />xml::ns                     attrSpace( attr-&gt;get_namespace() );<br /><br />std::cout &lt;&lt; "Attribute namespace: " &lt;&lt; attrSpace.get_prefix() &lt;&lt; "-&gt;"<br />          &lt;&lt; attrSpace.get_uri() &lt;&lt; std:endl;<br />root.add_namespace_definition( xml::ns( "myPrefix", "myURI" ),<br />                               xml::node::type_throw_if_exists );<br />root.set_namespace( "myPrefix" );<br />attr-&gt;set_namespace( "myPrefix" );</span></pre></div><div class="sec" id="ch_xmlwrapp.Use_an_Event_Parser"><h3><span class="title">Use an Event Parser</span></h3><p>For those within NCBI, there is <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp/event/test_event.cpp?revision=156258&amp;view=markup">sample code</a> showing how to use an event parser.</p></div><div class="sec" id="ch_xmlwrapp.Make_an_XSLT_Transfo"><h3><span class="title">Make an XSLT Transformation</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document         doc( "example.xml", NULL );<br />xslt::stylesheet      style( "example.xsl" );<br />xml::document         result = style.apply( doc );<br />std::string           tempString;<br /><br />std::cout &lt;&lt; "Result:\n" &lt;&lt; result &lt;&lt; std:endl;<br />// or<br />result.save_to_string( tempString );<br /><br />// you can also specify save options, e.g. to omit the XML declaration:<br />result.save_to_string( tempString, xml::save_op_no_decl );</span></pre><p>Other methods and options are available for saving the transformation result - see <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=save_to_stream">save_to_stream()</a>, <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=save_to_file">save_to_file()</a>, and <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=save_options">save_options</a>.</p><p><span class="nctnt highlight">Note:</span> The transformation output will be affected by a number of factors:</p><ul><li><p>If there is no output method specified in the XSL, or if the specified method is not "<span class="nctnt ncbi-monospace">html</span>" or "<span class="nctnt ncbi-monospace">text</span>", then the effective output method will be "<span class="nctnt ncbi-monospace">xml</span>".</p></li><li><p>On Windows, the effective output method will be "<span class="nctnt ncbi-monospace">xml</span>", regardless of the output method specified in the XSL.</p></li><li><p>The save options are only applicable when the effective output method is "<span class="nctnt ncbi-monospace">xml</span>".</p></li><li><p>If the effective output method is "<span class="nctnt ncbi-monospace">xml</span>", an XML declaration will be prepended to the transformation result when serialized (unless suppressed by the <span class="nctnt ncbi-var">xml::save_op_no_decl</span> save option).</p></li><li><p>There are three conditions for which an empty "<span class="nctnt ncbi-monospace">&lt;blank/&gt;</span>" node will be appended to the transformation output:</p><ul><li><p>The output method specified in the XSL is not "<span class="nctnt ncbi-monospace">xml</span>" or "<span class="nctnt ncbi-monospace">text</span>".</p></li><li><p>The output method specified in the XSL is "<span class="nctnt ncbi-monospace">xml</span>" but the XML is not well-formed.</p></li><li><p>The output method specified in the XSL is "<span class="nctnt ncbi-monospace">text</span>" and the platform is Windows.</p></li></ul></li></ul></div><div class="sec" id="ch_xmlwrapp.Run_an_XPath_Query"><h3><span class="title">Run an XPath Query</span></h3><pre><span class="nctnt-pre ncbi-code">xml::document                  doc( "example.xml", NULL );<br />xml::node &amp;                    root = doc.get_root_node();<br />xml::xpath_expression          expr( "/root/child" );<br />const xml::node_set            nset( root.run_xpath_query( expr ) );<br />size_t                         nnum( 0 );<br />xml::node_set::const_iterator  k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    std::cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; std::endl<br />         &lt;&lt; *k &lt;&lt; std::endl;</span></pre><p>Please note that the <span class="nctnt ncbi-var">node_set</span> object holds a set of references to the nodes from the document which is used to run the XPath query. Therefore you can change the nodes in the original document if you use a non-constant <span class="nctnt ncbi-var">node_set</span> and non-constant iterators.</p><p>The <span class="nctnt ncbi-var">xpath_expression</span> object also supports:</p><ul><li><p>pre-compilation of the XPath query string</p></li><li><p>namespace registration (a single namespace or a list of namespaces)</p></li></ul></div><div class="sec" id="ch_xmlwrapp.Run_an_XPath_Query_with_a_De"><h3><span class="title">Run an XPath Query with a Default Namespace</span></h3><p>The XPath specification does not support default namespaces, and it considers all nodes without prefixes to be in the null namespace, not the default namespace. This creates a problem when you want to search for nodes to which a default namespace applies, because the default namespace cannot be directly matched. For example, the following code will not find any matches:</p><pre><span class="nctnt-pre ncbi-code">std::string                     xmldata("&lt;A xmlns=\"http://nlm.nih.gov\"&gt;"<br />                                            "&lt;B&gt;&lt;C&gt;stuff&lt;/C&gt;&lt;/B&gt;"<br />                                        "&lt;/A&gt;" );<br />xml::document                   doc( xmldata.c_str(), xmldata.size(),<br />                                     NULL );<br />xml::node &amp;                     root = doc.get_root_node();<br />xml::xpath_expression           expr( "//B/C" );<br />const xml::node_set             nset( root.run_xpath_query( expr ) );<br />size_t                          nnum( 0 );<br />xml::node_set::const_iterator   k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    std::cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; std::endl<br />         &lt;&lt; *k &lt;&lt; std::endl;</span></pre><p>The solution is to create a special namespace with the sole purpose of associating a made-up prefix with the URI of the default namespace. Use that namespace when creating the XPath expression, and prefix the nodes in your XPath expression with your made-up prefix. This prefix should be distinct from other prefixes in the document. The following code will find the desired node:</p><pre><span class="nctnt-pre ncbi-code">std::string                     xmldata("&lt;A xmlns=\"http://nlm.nih.gov\"&gt;"<br />                                            "&lt;B&gt;&lt;C&gt;stuff&lt;/C&gt;&lt;/B&gt;"<br />                                        "&lt;/A&gt;" );<br />xml::document                   doc( xmldata.c_str(), xmldata.size(),<br />                                     NULL );<br />xml::node &amp;                     root = doc.get_root_node();<br /><br />                                // here we add a made-up namespace<br />xml::ns                         fake_ns( "fake_pfx", "http://nlm.nih.gov" );<br /><br />                                // now we register the made-up namespace and<br />                                // use the made-up prefix<br />xml::xpath_expression           expr( "//fake_pfx:B/fake_pfx:C", fake_ns );<br /><br />const xml::node_set             nset( root.run_xpath_query( expr ) );<br />size_t                          nnum( 0 );<br />xml::node_set::const_iterator   k( nset.begin() );<br /><br />for ( ; k != nset.end(); ++k )<br />    std::cout &lt;&lt; "Node #" &lt;&lt; nnum++ &lt;&lt; std::endl<br />         &lt;&lt; *k &lt;&lt; std::endl;</span></pre></div><div class="sec" id="ch_xmlwrapp.Use_an_Extension_Function"><h3><span class="title">Use an Extension Function</span></h3><pre><span class="nctnt-pre ncbi-code">class myExtFunc : public xslt::extension_function<br />{<br />    public:<br />        void execute (const std::vector&lt;xslt::xpath_object&gt; &amp;  args,<br />                      const xml::node &amp;                        node,<br />                      const xml::document &amp;                    doc)<br />        {<br />            set_return_value( xslt::xpath_object( 42 ) );<br />        }<br />};<br /><br />//...<br /><br />    std::string             doc_as_string = "&lt;root&gt;&lt;nested/&gt;&lt;/root&gt;";<br />    xml::document           doc( doc_as_string.c_str(),<br />                                 doc_as_string.size(), NULL );<br /><br />    std::string             style_as_string =<br />                                "&lt;xsl:stylesheet xmlns:xsl="<br />                                "\"http://www.w3.org/1999/XSL/Transform\" "<br />                                "xmlns:my=\"http://bla.bla.bla\"&gt;"<br />                                "&lt;xsl:output method=\"text\"/&gt;"<br />                                "&lt;xsl:template match=\"/root/nested\"&gt;"<br />                                "&lt;xsl:value-of select=\"my:test(15)\"/&gt;"<br />                                "&lt;/xsl:template&gt;"<br />                                "&lt;/xsl:stylesheet&gt;";<br />    xslt::stylesheet        sheet( style_as_string.c_str(),<br />                                   style_as_string.size() );<br /><br />    myExtFunc *             myFunc = new myExtFunc;<br />    sheet.register_extension_function( myFunc, "test", "http://bla.bla.bla",<br />                                       xml::type_own );<br />    // sheet now owns myFunc, so there is no need to delete myFunc<br /><br />    xml::document           result = sheet.apply( doc );<br /><br />    std::cout &lt;&lt; result &lt;&lt; std::endl; // "42"</span></pre><p>Please also see the <span class="nctnt ncbi-class">xslt::extension-function</span> <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classxslt_1_1extension__function.html">class reference</a>.</p><p>Users inside NCBI can view the <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp/xslt_ext_func/">extension function unit tests</a> for more usage examples.</p></div><div class="sec" id="ch_xmlwrapp.Use_an_Extension_Element"><h3><span class="title">Use an Extension Element</span></h3><pre><span class="nctnt-pre ncbi-code">class myExtElem : public xslt::extension_element<br />{<br />    public:<br />        void process (xml::node &amp;               input_node,<br />                      const xml::node &amp;         instruction_node,<br />                      xml::node &amp;               insert_point,<br />                      const xml::document &amp;     doc)<br />        {<br />            xml::node   my( "inserted", "content" );<br />            insert_point.push_back( my );<br />        }<br />};<br /><br />// ...<br /><br />    std::string             doc_as_string = "&lt;root&gt;&lt;nested/&gt;&lt;/root&gt;";<br />    xml::document           doc( doc_as_string.c_str(),<br />                                 doc_as_string.size(), NULL );<br /><br />    std::string             style_as_string =<br />                                "&lt;xsl:stylesheet xmlns:xsl="<br />                                "\"http://www.w3.org/1999/XSL/Transform\" "<br />                                "xmlns:my=\"http://bla.bla.bla\" "<br />                                "extension-element-prefixes=\"my\"&gt;"<br />                                "&lt;xsl:output method=\"xml\"/&gt;"<br />                                "&lt;xsl:template match=\"/root/nested\"&gt;"<br />                                "&lt;my:test/&gt;"<br />                                "&lt;/xsl:template&gt;"<br />                                "&lt;/xsl:stylesheet&gt;";<br />    xslt::stylesheet        sheet( style_as_string.c_str(),<br />                                   style_as_string.size() );<br /><br />    myExtElem *             myElem = new myExtElem;<br />    sheet.register_extension_element( myElem, "test", "http://bla.bla.bla",<br />                                      xml::type_own );<br />    // sheet now owns myElem, so there is no need to delete myElem<br /><br />    xml::document           result = sheet.apply( doc );<br />    xml::node &amp;             result_root = result.get_root_node();<br /><br />    std::cout &lt;&lt; result_root.get_name() &lt;&lt; std::endl; // "inserted"<br />    std::cout &lt;&lt; result_root.get_content() &lt;&lt; std::endl; // "content"</span></pre><p>Please also see the <span class="nctnt ncbi-class">xslt::extension-element</span> <a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classxslt_1_1extension__element.html">class reference</a>.</p><p>Users inside NCBI can view the <a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++/src/internal/test/misc/xmlwrapp/xslt_ext_elem/">extension element unit tests</a> for more usage examples.</p></div><div class="sec" id="ch_xmlwrapp.Use_an_XML_Catalog"><h3><span class="title">Use an XML Catalog</span></h3><p>The <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> environment variable may be used in one of three ways to control the XML catalog feature of <span class="nctnt ncbi-lib">libxml2</span> â€“ i.e. the way <span class="nctnt ncbi-lib">libxml2</span> resolves unreachable external URI's:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">If <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> is not set in the process environment then the default catalog will be used.</p></dd><dt>2</dt><dd><p class="no_top_margin">If it is set to an empty value then the default catalog will be deactivated and there will be no resolution of unreachable external URI's.</p></dd><dt>3</dt><dd><p class="no_top_margin">If it is set to a space-separated list of catalog files, then <span class="nctnt ncbi-lib">libxml2</span> will use these files to resolve external URI's. Any invalid paths will be silently ignored.</p></dd></dl><p>The default catalog is <span class="nctnt ncbi-path">/etc/xml/catalog</span> for non-Windows systems. For Windows, the default catalog is <span class="nctnt ncbi-path">&lt;module_path&gt;\..\etc\catalog</span>, where <span class="nctnt ncbi-path">&lt;module_path&gt;</span> is the path to the installed <span class="nctnt ncbi-path">libxml2.dll</span>, if available, otherwise the path to the running program.</p><p>The <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> environment variable is read once before the first parsing operation, and then any specified catalogs are used globally for URI resolution in all subsequent parsing operations. Therefore, if the <span class="nctnt ncbi-var">XML_CATALOG_FILES</span> value is to be set programmatically, it must be done prior to the first parsing operation.</p><p>There is another environment variable (<span class="nctnt ncbi-var">XML_DEBUG_CATALOG</span>) to control debug output. If it is defined, then debugging output will be enabled.</p></div></div><div class="sec" id="ch_xmlwrapp.Warning_Collaborative_Use_of"><h2><span class="title">Warning: Collaborative Use of XmlWrapp and libxml2</span></h2><p>XmlWrapp uses the <span class="nctnt ncbi-var">_private</span> field of the raw <span class="nctnt ncbi-lib">libxml2 </span><span class="nctnt ncbi-type">xmlNode</span> data structure for internal purposes. Therefore, if <span class="nctnt ncbi-lib">libxml2</span> and XmlWrapp are used collaboratively then this field must not be used in client code. If it is used, it may cause a core dump or other undefined behavior.</p></div><div class="sec" id="ch_xmlwrapp.Implementation_Details"><h2><span class="title">Implementation Details</span></h2><div class="sec" id="ch_xmlwrapp.Copying_and_Referencing_Node"><h3><span class="title">Copying and Referencing Nodes</span></h3><p><span class="nctnt ncbi-class">xml::node</span> objects are frequently required when working with XML documents. There are two ways to work with a given node:</p><ul><li><p>by referencing it; or</p></li><li><p>by copying it.</p></li></ul><p>This example shows both ways:</p><pre><span class="nctnt-pre ncbi-code">xml::document       doc( "example.xml", NULL );<br />xml::node_set       nset( doc.get_root_node().<br />                                  run_xpath_query( "/root/child" ) );<br /><br />// Iterate over the result node set<br />xml::node_set::iterator     k = nset.begin();<br />for ( ; k != nset.end(); ++k ) {<br /><br />    // just reference the existing node<br />    xml::node &amp;     node_ref = *k;<br /><br />    // create my own copy (which I'll own and destroy)<br />    xml::node *     my_copy = k-&gt;detached_copy();<br /><br />    // Do something<br />    ...<br /><br />    // Don't forget this<br />    delete my_copy;<br />}</span></pre><p>What is the difference between the <span class="nctnt ncbi-var">node_ref</span> and <span class="nctnt ncbi-var">my_copy</span> variables?</p><p>The <span class="nctnt ncbi-var">node_ref</span> variable refers to a node in the original document loaded from <span class="nctnt ncbi-path">example.xml</span>. If you change something using the <span class="nctnt ncbi-var">node_ref</span> variable youâ€™ll make changes in the original document object.</p><p>The <span class="nctnt ncbi-var">my_copy</span> variable is a recursive copy of the corresponding node together with all used namespace definitions, non-default attributes, and nested nodes. The copy has no connection to the original document. The <span class="nctnt ncbi-var">my_copy</span> variable has no parent node and has no links to the internal and external subsets (DTDs) which the original document could have. If you change something using the <span class="nctnt ncbi-var">my_copy</span> variable youâ€™ll make changes in the copy but not in the original document. Obviously it takes more time to create such a recursive copy of a node.</p><p><span class="nctnt highlight">Note:</span> It is recommended to pass nodes by reference when appropriate to maximize performance and avoid modification of copies.</p></div><div class="sec" id="ch_xmlwrapp.Using_Namespaces_with_XPath"><h3><span class="title">Using Namespaces with XPath Expressions</span></h3><p>XmlWrapp provides the <span class="nctnt ncbi-class">xml::xpath_expression</span> class for building reusable XPath expressions. If namespaces are involved then one of the constructors which accept a namespace or a list of namespaces should be used. Otherwise the XPath query results may not have the nodes you expect to get.</p><p>XmlWrapp also provides a convenience method for the nodes: <span class="nctnt ncbi-func">xml::node::run_xpath_query( const char * expr)</span>. This method builds an <span class="nctnt ncbi-class">xpath_expression</span> internally and registers all the effective namespaces for the certain node. While it is very convenient as you donâ€™t need to know in advance what the namespace definitions are, this method has some drawbacks:</p><ul><li><p>The internally built <span class="nctnt ncbi-class">xpath_expression</span> is not reusable, so it gets rebuilt every time a query is run - even if the same expression was used before.</p></li><li><p>The list of effective namespace definitions for a certain node can be quite long and may exceed your actual needs. It takes time to build such a list and to register them all so it affects the performance.</p></li></ul><p>Recommendations:</p><ul><li><p>If you need the best performance then use <span class="nctnt ncbi-class">xml::xpath_expression</span> explicitly and do not forget to provide a list of the required namespaces.</p></li><li><p>If you arenâ€™t concerned about performance then use one of the <span class="nctnt ncbi-func">xml::node::run_xpath_query( const char * expr)</span> methods.</p></li></ul></div><div class="sec" id="ch_xmlwrapp.Containers_of_Attributes__It"><h3><span class="title">Containers of Attributes - Iteration and Size</span></h3><p>Sometimes it is necessary to iterate over a node's attributes or to find an attribute. Letâ€™s take a simple example:</p><pre>&lt;?xml version="1.0" ?&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      attr1       = "val1"<br />      foo         = "fooVal"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>XmlWrapp provides an STL-like way of iterating over the attributes, e.g:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode ) {<br />    const xml::attributes &amp;  attrs = theNode.get_attributes();<br /><br />    for ( xml::attributes::const_iterator  k = attrs.begin();<br />          k != attrs.end(); ++k )<br />        std::cout &lt;&lt; "Attribute name: " &lt;&lt; k-&gt;get_name()<br />                  &lt;&lt; " value: " &lt;&lt; k-&gt;get_value() &lt;&lt; std::endl;<br />}</span></pre><p>You may notice that iterators are used here and the iterators can be incremented.</p><p><span class="nctnt highlight">Note:</span> Although iterating over attributes is STL-like, searching for an attribute is only partially STL-like. Iterators returned by the <span class="nctnt ncbi-func">find()</span> method cannot be incremented, but both operator <span class="nctnt ncbi-code">-&gt;</span> and operator <span class="nctnt ncbi-code">*</span> can be used. The following code will work:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode, const char *  attrName ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( attrName );<br /><br />    if ( found != attrs.end() )<br />        std::cout &lt;&lt; "Found name: " &lt;&lt; (*found).get_name()<br />                  &lt;&lt; "Found value: " &lt;&lt; found-&gt;get_value() &lt;&lt; std::endl;<br />}</span></pre><p>but this code will generate an exception:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode, const char *  attrName ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( attrName );<br /><br />    if ( found != attrs.end() )<br />        ++found;  // Exception is guaranteed here<br />}</span></pre><p>This implementation detail is related to the limitations of <span class="nctnt ncbi-lib">libxml2</span> with respect to default attributes. Letâ€™s take an example that has a DTD:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;!DOCTYPE root PUBLIC "something" "my.dtd" [<br />&lt;!ATTLIST root defaultAttr CDATA "defaultVal"&gt;<br />]&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      attr1       = "val1"<br />      foo         = "fooVal"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>This example introduces a default attribute called defaultAttr for the root node. The <span class="nctnt ncbi-lib">libxml2</span> library stores default and non-default attributes separately. The library provides very limited access the default attributes - there is no way to iterate over them and the only possible way to get a default attribute is to search for it explicitly. For example:</p><pre><span class="nctnt-pre ncbi-code">void f( const xml::node &amp;  theNode ) {<br />    const xml::attributes &amp;          attrs = theNode.get_attributes();<br />    xml::attributes::const_iterator  found = attrs.find( "defaultAttr" );<br /><br />    if ( found != attrs.end() ) {<br />        std::cout &lt;&lt; "Default? " &lt;&lt; found-&gt;is_default() &lt;&lt; std::endl;<br />        std::cout &lt;&lt; "Name: " &lt;&lt; found-&gt;get_name()<br />                  &lt;&lt; " Value: " &lt;&lt; found-&gt;get_value() &lt;&lt; std::endl;<br />    }<br />}</span></pre><p>XmlWrapp forbids incrementing iterators provided by <span class="nctnt ncbi-func">xml::attributes::find(...)</span> methods because:</p><ul><li><p><span class="nctnt ncbi-lib">libxml2</span> has limited support for working with default attributes; and</p></li><li><p>iterators provided by the <span class="nctnt ncbi-func">xml::attributes::find()</span> methods may point to either a default or a non-default attribute.</p></li></ul><p><span class="nctnt highlight">Note:</span> This <span class="nctnt ncbi-lib">libxml2</span> limitation affects the <span class="nctnt ncbi-func">xml::attributes::size()</span> method behavior. It will always provide the number of non-default attributes and will never include the number of default attributes regardless of whether or not a node has default attributes.</p></div><div class="sec" id="ch_xmlwrapp.Changing_Default_Attributes"><h3><span class="title">Changing Default Attributes</span></h3><p><span class="nctnt ncbi-lib">libxml2</span> does not provide the ability to change a default attribute. XmlWrapp does provide this ability, but at the cost of implicitly converting the default attribute into a non-default attribute. Consider the following document:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;!DOCTYPE root PUBLIC "something" "my.dtd" [<br />&lt;!ATTLIST root language CDATA "EN"&gt;<br />]&gt;<br />&lt;root xmlns:some_ns="http://the.com"<br />      some_ns:bar = "barVal"&gt;<br />&lt;/root&gt;</pre><p>The code below demonstrates changing a default attribute and is totally OK as explained in the comments (error handling is omitted for clarity):</p><pre><span class="nctnt-pre ncbi-code">xml::document               doc( "example.xml", NULL );<br />xml::node &amp;                 root = doc.get_root_node();<br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   j = attrs.find( "language" );<br /><br />// Here j points to the default attribute<br />assert( j-&gt;is_default() == true );<br /><br />// Now suppose we need to change the default language to French.<br />// It is forbidden to change the default attribute's values because<br />// the default attribute might be applied to many nodes while a change<br />// could be necessary for a single node only.<br />// So, to make a change operation valid, XmlWrapp first converts the default<br />// attribute to a non-default one and then changes its value.<br /><br />j-&gt;set_value( "FR" );<br /><br />// Now the iterator j is still valid and points to a non-default attribute<br />assert( j != attrs.end() );<br />assert( j-&gt;is_default() == false );<br /><br />// If you decide to save the document at this point then youâ€™ll see<br />// the root node with one node attribute language="FR"</span></pre><p>A similar conversion will happen if you decide to change a default attribute namespace.</p><p>XmlWrapp will also ensure that all iterators pointing to the same attribute remain consistent when multiple iterators point to the same default attribute and one of them is changed. For example:</p><pre><span class="nctnt-pre ncbi-code">xml::document               doc( "example.xml", NULL );<br />xml::node &amp;                 root = doc.get_root_node();<br />xml::attributes &amp;           attrs = root.get_attributes();<br />xml::attributes::iterator   j = attrs.find( "language" );<br />xml::attributes::iterator   k = attrs.find( "language" );<br /><br />// Here we have two iterators j and k pointing to the same default attribute<br />assert( j-&gt;is_default() == true );<br />assert( k-&gt;is_default() == true );<br /><br />// Now the attribute is implicitly converted to a non-default one<br />// using one of the iterators<br />j-&gt;set_value( "FR" );<br /><br />// Both j and k iterators are now pointing to a non-default (ex-default)<br />// attribute<br />assert( j-&gt;is_default() == false );<br />assert( k-&gt;is_default() == false );<br /><br />// And of course:<br />assert( j-&gt;get_value() == std::string( "FR" ) );<br />assert( k-&gt;get_value() == std::string( "FR" ) );</span></pre><p>For a diagram illustrating how the XmlWrapp library handles iterators and changed default attributes, please see <a href="ch_xmlwrapp.html#ch_xmlwrapp.1.2">Figure 1, Phantom Attributes</a>.</p><div class="figure" id="ch_xmlwrapp.1.2"><div class="graphic"><a href="img/ch_xmlwrapp_phantom_attr.png" class="img_link" target="_blank" title="Click to see the full-resolution image"><img src="img/ch_xmlwrapp_phantom_attr.png" alt="Figure 1. Phantom Attributes." /></a></div><div class="caption"><p>Figure 1. Phantom Attributes.</p></div></div></div><div class="sec" id="ch_xmlwrapp.Event_Parser_and_Named_Entit"><h3><span class="title">Event Parser and Named Entities</span></h3><p>When using <span class="nctnt ncbi-class">xml::event_parser</span>, three functions are involved in parsing an XML document that contains named entities:</p><ul><li><p><span class="nctnt ncbi-func">xml::init::substitute_entities()</span><br />This method controls whether the <span class="nctnt ncbi-func">xml::event_parser::entity_reference()</span> callback is called or not, and must be called before the event parser is created.</p></li><li><p><span class="nctnt ncbi-func">xml::event_parser::text()</span><br />This callback will be called for both text nodes and named entity nodes.</p></li><li><p><span class="nctnt ncbi-func">xml::event_parser::entity_reference()</span><br />This callback may be called for named entity nodes.</p></li></ul><p>Imagine that an event parser which implements both <span class="nctnt ncbi-func">text()</span> and <span class="nctnt ncbi-func">entity_reference()</span> callbacks receives the following document as in input:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;!DOCTYPE EXAMPLE SYSTEM "example.dtd" [ &lt;!ENTITY my "VALUE"&gt;]&gt;<br />&lt;root&gt;&lt;node&gt;Super &amp;my; oh!&lt;/node&gt;&lt;/root&gt;</pre><p>Then the table below lists the callbacks that are called, depending on the value passed to <span class="nctnt ncbi-func">substitute_entities()</span>:</p><div class="table" id="ch_xmlwrapp.T.nc_having_this_call_before"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Having this call before the parser is created:<br /><span class="nctnt ncbi-code">xml::init::substitute_entities(true)</span><br />results in the following callbacks:</th><th align="left" valign="top" rowspan="1" colspan="1">Having this call before the parser is created:<br /><span class="nctnt ncbi-code">xml::init::substitute_entities(false)</span><br />results in the following callbacks:</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text("Super ")</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text("Super ")</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text("VALUE")</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text("VALUE")</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::entity_reference("my")</span></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text(" oh!")</span></td><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-code">xml::event_parser::text(" oh!")</span></td></tr></tbody></table></div></div><p>So the difference is that the <span class="nctnt ncbi-func">entity_reference()</span> callback is never called if <span class="nctnt ncbi-func">substitute_entities(true)</span> is called. <span class="nctnt highlight">Note:</span> The <span class="nctnt ncbi-func">entity_reference()</span> callback is also not called if a standard entity is used (e.g. <span class="nctnt ncbi-var">&amp;apos;</span>, <span class="nctnt ncbi-var">&amp;amp;</span>, <span class="nctnt ncbi-var">&amp;quot;</span>, <span class="nctnt ncbi-var">&amp;lt;</span>, <span class="nctnt ncbi-var">&amp;gt;</span>), regardless of any call to <span class="nctnt ncbi-func">substitute_entities()</span>.</p><p>Character entities are handled the same way as named entities.</p><p>Generally speaking, the event parser in XmlWrapp behaves the same way as in <span class="nctnt ncbi-lib">libxml2</span> in terms of what callbacks are called - except that the callbacks in XmlWrapp are C++ methods whereas the callbacks in <span class="nctnt ncbi-lib">libxml2</span> are C functions.</p></div><div class="sec" id="ch_xmlwrapp.Safe_and_Unsafe_Namespaces"><h3><span class="title">Safe and Unsafe Namespaces</span></h3><p>XmlWrapp provides a wrapper class called <span class="nctnt ncbi-class">xml::ns</span> to work with namespaces. The <span class="nctnt ncbi-class">xml::ns</span> class can be of two types: safe and unsafe.</p><p>To understand the difference between them it is necessary to know how <span class="nctnt ncbi-lib">libxml2</span> works with namespaces. Namespace structures in <span class="nctnt ncbi-lib">libxml2</span> store two pointers to character strings - a namespace prefix and a namespace URI. These structures are stored in a linked list and each XML document element that might have a namespace has a pointer that points to a namespace structure. Thus, namespaces can be uniquely identified by either a namespace pointer or by a prefix / URI pair.</p><p>XmlWrapp covers both ways. The <span class="nctnt ncbi-class">xml::ns</span> can store its own copies of the namespace prefix and URI, and in this case the namespace is called safe. Or, the <span class="nctnt ncbi-class">xml::ns</span> can store just a pointer to the corresponding namespace structure, and in this case the namespace is called unsafe.</p><p><span><a href="img/ch_xmlwrapp_xmlns.png" class="img_link" target="_blank" title="Click to see the full-resolution image"><img src="img/ch_xmlwrapp_xmlns.png" alt="Image ch_xmlwrapp_xmlns.png" /></a></span></p><p>A safe namespace can be constructed based on strings provided by the user or by making copies of the prefix and URI strings extracted from the <span class="nctnt ncbi-lib">libxml2</span> low level structure. Having a copy of the strings makes it absolutely safe to manipulate namespaces - it is even possible to get a namespace from one document, destroy the document, and then apply the stored namespace to another document.</p><p>When XmlWrapp receives an unsafe namespace for a namespace manipulation operation, it does not perform any checks and uses the raw pointer as-is. So there is a chance to break your document and even cause your application to core dump if an unsafe namespace is used improperly. For example the user may take an unsafe namespace from one document, destroy the document, and then apply the stored unsafe namespace to another document. At the time the original document is destroyed the low level namespace structure is destroyed as well but the pointer to the namespace is still stored so any access operation will cause problems.</p><p>Unsafe namespaces have some advantages though. They require less memory and they work faster. So the recommendation is to use safe namespaces unless you really need the best possible performance and slight reduction of the memory footprint.</p></div><div class="sec" id="ch_xmlwrapp.Thread_Safety"><h3><span class="title">Thread Safety</span></h3><p>There are two major sources of thread unsafety when the XmlWrapp library is used:</p><ul><li><p>The <a href="http://xmlsoft.org/">libxml2</a> and <a href="http://xmlsoft.org/XSLT/">libxslt</a> code</p></li><li><p>The XmlWrapp code</p></li></ul><p>It is hard to say exactly where libxml2 and libxslt are not thread safe, so this topic is not discussed in this document. However, if your code doesn't break any of the following statements then you are on the safe side in terms of thread safety in XmlWrapp:</p><dl class="labeled-list"><dt>1</dt><dd><p class="no_top_margin">It is thread-safe to work with different documents from different threads.</p></dd><dt>2</dt><dd><p class="no_top_margin">It is not thread-safe to modify the same document from different threads.</p></dd><dt>3</dt><dd><p class="no_top_margin">It is thread-safe to perform non-modifying operations on the same document in different threads except in the following cases:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin">Applying the same stylesheet to different documents. This case is related to the fact that a result document needs a reference to the stylesheet so there is reference counting. (Note: This exception does not apply if the compiler is C++11 conformant.)</p></dd><dt>b</dt><dd><p class="no_top_margin">Using copies of XPath query result node sets in different threads. This case is also related to reference counting because node sets are not really copied but reference counting is used instead.</p></dd><dt>c</dt><dd><p class="no_top_margin">The following operations are not thread-safe when performed on the same node from different threads in any combination:</p><dl class="labeled-list"><dt>i</dt><dd><p class="no_top_margin">Dereferencing the node iterator.</p></dd><dt>ii</dt><dd><p class="no_top_margin">Dereferencing the node attributes iterator.</p></dd><dt>iii</dt><dd><p class="no_top_margin">Searching for an attribute of the node.</p></dd></dl></dd></dl></dd></dl><p>The last case is tied to the fact that XmlWrapp is a very thin wrapper and it tends to introduce minimal overhead. In order to keep node references valid when iterators are advanced some private data are attached to the nodes that an iterator points to. The same happens when an attribute iterator is dereferenced. When attribute searching is done it particularly analyses the node private data (because some default attribute values could be changed) and thus causes thread unsafety.</p></div><div class="sec" id="ch_xmlwrapp.Safe_libxml2_and_libxslt_Cle"><h3><span class="title">Safe libxml2 and libxslt Cleanup</span></h3><p><i>libxml2 cleanup</i></p><p>By default, XmlWrapp automatically initiates cleanup of <span class="nctnt ncbi-lib">libxml2</span> library data by calling <span class="nctnt ncbi-func">xmlCleanupParser()</span> (which is part of <span class="nctnt ncbi-lib">libxml2</span>). Programs that use <span class="nctnt ncbi-lib">libxml2</span> only through XmlWrapp therefore don't have to take any explicit cleanup steps for <span class="nctnt ncbi-lib">libxml2</span> data.</p><p>However, some programs use <span class="nctnt ncbi-lib">libxml2</span> outside of XmlWrapp in a way that requires explicit steps to prevent a program crash.</p><p>For example, suppose your program uses both XmlWrapp and some other <span class="nctnt ncbi-lib">libxml2</span>-based library, and suppose that the other library also cleans up by calling <span class="nctnt ncbi-func">xmlCleanupParser()</span>. In this case, <span class="nctnt ncbi-func">xmlCleanupParser()</span> will be called twice. It could even be called more than twice if, for example, multiple threads use the other library.</p><p>Unfortunately, <span class="nctnt ncbi-lib">libxml2</span>'s <span class="nctnt ncbi-func">xmlCleanupParser()</span> wasn't designed to be called more than once, and multiple calls can cause a crash.</p><p>Therefore, it is the responsibility of your program to ensure that <span class="nctnt ncbi-func">xmlCleanupParser()</span> will be called only once. How it accomplishes that in the case of multi-threaded use of third-party libraries (or any other scenario that results in multiple calls to <span class="nctnt ncbi-func">xmlCleanupParser()</span> outside of XmlWrapp), is beyond the scope of XmlWrapp and this document.</p><p>However, XmlWrapp does provide a way to prevent a crash when a <i>single</i> <span class="nctnt ncbi-func">xmlCleanupParser()</span> call is made outside XmlWrapp. In this case your program can prevent XmlWrapp from calling <span class="nctnt ncbi-func">xmlCleanupParser()</span> using:</p><pre><span class="nctnt-pre ncbi-code">xml::init::library_cleanup_on_exit(false);</span></pre><p>Your program should also make sure that XmlWrapp finishes all its data handling before the other part calls <span class="nctnt ncbi-func">xmlCleanupParser()</span>. This approach will prevent XmlWrapp from calling <span class="nctnt ncbi-func">xmlCleanupParser()</span>, and the other use of <span class="nctnt ncbi-func">xmlCleanupParser()</span> will be safe.</p><p><i>libxslt cleanup</i></p><p>The situation for <span class="nctnt ncbi-lib">libxslt</span> cleanup is essentially the same as described above for <span class="nctnt ncbi-lib">libxml2</span>, except that the problem arises from <span class="nctnt ncbi-func">xsltCleanupGlobals()</span> in addition to <span class="nctnt ncbi-func">xmlCleanupParser()</span>. Therefore, if your program makes a call to <span class="nctnt ncbi-func">xsltCleanupGlobals()</span> outside XmlWrapp (either directly or through a library), then it should use:</p><pre><span class="nctnt-pre ncbi-code">xml::init::library_cleanup_on_exit(false);<br />xslt::init::library_cleanup_on_exit(false);</span></pre><p>Your program should also make sure that XmlWrapp finishes all its data handling before the other part calls <span class="nctnt ncbi-func">xsltCleanupGlobals()</span> and <span class="nctnt ncbi-func">xmlCleanupParser()</span>.</p></div><div class="sec" id="ch_xmlwrapp.Formatting_of_Programmatical"><h3><span class="title">Formatting of Programmatically Added Content</span></h3><div class="sec" id="ch_xmlwrapp.How_libxml2_handles_formatti"><h4><span class="title">How libxml2 handles formatting of programmatically added content </span></h4><p>In some cases, programmatically adding content to an <span class="nctnt ncbi-class">xml::document</span> object and subsequently serializing to a string or stream will result in unformatted output of the added content. This is due to a section of code within the <span class="nctnt ncbi-lib">libxml2</span> library that gets called when programmatically added nodes are serialized to a string or stream. As the code traverses the tree, it checks if the current node is text-like - i.e. if it's a text, CDATA, or entity reference node. If so, it turns off formatting for that node and any nested nodes. This is presumably intended to prevent the library's formatting code from overriding any formatting already contained in the node, but it has the effect of preventing automatic formatting of programmatically-added content. Because this behavior is a feature of <span class="nctnt ncbi-lib">libxml2</span>, there is no way to switch it off through XmlWrapp.</p><p>To illustrate this, imagine that you have created an XML document from the following pretty-printed XML file:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;child/&gt;<br />&lt;/root&gt;</pre><p>Then you insert the following subtree before the child node:</p><pre>&lt;new_1&gt;&lt;new_2/&gt;&lt;/new_1&gt;</pre><p>You might expect <span class="nctnt ncbi-func">save_to_string()</span> to produce:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;new_1&gt;<br />        &lt;new_2/&gt;<br />    &lt;/new_1&gt;<br />    &lt;child/&gt;<br />&lt;/root&gt;</pre><p>But instead it produces:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;new_1&gt;&lt;new_2/&gt;&lt;/new_1&gt;&lt;child/&gt;<br />&lt;/root&gt;</pre><p>This is because the original document contained a text-node (the newline and space) immediately following the opening tag of the root element, and therefore:</p><dl class="labeled-list"><dt>a</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-lib">libxml2</span> does not alter the original content - i.e. the pretty-printing of the original content is reproduced intact; and</p></dd><dt>b</dt><dd><p class="no_top_margin"><span class="nctnt ncbi-lib">libxml2</span> does not alter the inserted content - i.e. the inserted content contained no formatting to start with, and none is added, so the new content is inserted immediately before the child node.</p></dd></dl><p>However, if you start with:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;&lt;child/&gt;&lt;/root&gt;</pre><p>Then inserting &lt;new_1&gt;&lt;new_2/&gt;&lt;/new_1&gt; and calling <span class="nctnt ncbi-func">save_to_string()</span> will produce:</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />  &lt;new_1&gt;<br />    &lt;new_2/&gt;<br />  &lt;/new_1&gt;<br />  &lt;child/&gt;<br />&lt;/root&gt;</pre><p>This is because neither the original nor the modified document contains any text nodes, so <span class="nctnt ncbi-lib">libxml2</span> formats the entire thing.</p><p>That is how <span class="nctnt ncbi-lib">libxml2</span> works.</p><p>While this may not be desirable in certain circumstances, there is no generic and reliable way to detect which text nodes are used for formatting, and which are meaningful content, so it's not feasible to make XmlWrapp adjust inserted content to make it get automatically formatted. Therefore, if the <span class="nctnt ncbi-lib">libxml2</span> formatting behavior is undesirable, either you'll have to ensure that your documents do not contain any text-like nodes prior to calling <span class="nctnt ncbi-func">save_to_string()</span>, or you'll have to create your own code for formatting content prior to inserting it.</p></div><div class="sec" id="ch_xmlwrapp.How_you_can_influence_format"><h4><span class="title">How you can influence formatting of programmatically added content </span></h4><p>There are two ways that you can influence the formatting of programmatically added content:</p><ul><li><p>by using (or not using) text-like nodes in the added content; and</p></li><li><p>by choosing an appropriate <span class="nctnt ncbi-var">xml::save_options</span> flag.</p></li></ul><p>For the purposes of this chapter, a "text-like node" is a text, CDATA, or entity reference node in the XML tree that is built when the original content is parsed. Newlines and whitespace used for indentation are parsed into text nodes. Note, however, that whitespace characters between the XML declaration and the opening tag of the root node are not treated by libxml2 as part of the node tree - i.e. whitespace characters prior to the root node do not participate in formatting of the output.</p><p>The following sections illustrate how various formatting flags affect the output for both content containing text-like nodes and content not containing text-like nodes. Note that although only <span class="nctnt ncbi-func">save_to_string()</span> is mentioned, the discussion aplies equally to all the <span class="nctnt ncbi-func">save_to_*()</span> functions because they all use the same underlying formatting code.</p><ul><li><p><a href="ch_xmlwrapp.html#ch_xmlwrapp.Original_containing_textli_1">Original containing text-like nodes</a></p></li><li><p><a href="ch_xmlwrapp.html#ch_xmlwrapp.Original_containing_textli_2">Original containing text-like nodes and having programmatically inserted content</a></p></li><li><p><a href="ch_xmlwrapp.html#ch_xmlwrapp.Original_not_containing_te_1">Original not containing text-like nodes</a></p></li><li><p><a href="ch_xmlwrapp.html#ch_xmlwrapp.Original_not_containing_te_2">Original not containing text-like nodes and having programmatically inserted content</a></p></li></ul><div class="sec" id="ch_xmlwrapp.Original_containing_textli_1"><h5><span class="title">Original containing text-like nodes</span></h5><p>Given the following original document (which contains text-like nodes for indenting and has not been programmatically modified):</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre><p>Then the <span class="nctnt ncbi-func">save_to_string()</span> function will produce the following outputs for the given formatting flags:</p><div class="table" id="ch_xmlwrapp.T.nc_flagsoutputxmlsave_op_1"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag(s)</th><th align="left" valign="top" rowspan="1" colspan="1">Output</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_default</span><br /><span class="nctnt ncbi-var">xml::save_op_no_format</span><br /><span class="nctnt ncbi-var">xml::save_op_no_empty</span><br /><span class="nctnt ncbi-var">xml::save_op_no_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_not_as_xml</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_decl</span><br /><span class="nctnt ncbi-var">xml::save_op_as_html</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;<br />    &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_with_non_significant_ws</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root<br />  &gt;<br />    &lt;child<br />      attr="AttrValue"<br />    &gt;content&lt;/child<br />  &gt;<br />&lt;/root<br />&gt;</pre></td></tr></tbody></table></div></div></div><div class="sec" id="ch_xmlwrapp.Original_containing_textli_2"><h5><span class="title">Original containing text-like nodes and having programmatically inserted content</span></h5><p>Given the following original document (which contains text-like nodes for indenting):</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre><p>And given that a node has been programmatically inserted like this:</p><pre><span class="nctnt-pre ncbi-code">xml::node &amp;             root = doc.get_root_node();<br />xml::node::iterator     insert_before;<br /><br />insert_before = root.find( "child" );<br />root.insert( insert_before, xml::node("inserted") );</span></pre><p>Then the <span class="nctnt ncbi-func">save_to_string()</span> function will produce the following outputs for the given formatting flags:</p><div class="table" id="ch_xmlwrapp.T.nc_flagsoutputxmlsave_op_2"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag(s)</th><th align="left" valign="top" rowspan="1" colspan="1">Output</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_default</span><br /><span class="nctnt ncbi-var">xml::save_op_no_format</span><br /><span class="nctnt ncbi-var">xml::save_op_no_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_not_as_xml</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;inserted/&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_decl </span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;<br />    &lt;inserted/&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_empty</span><br /><span class="nctnt ncbi-var">xml::save_op_xhtml </span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />    &lt;inserted&gt;&lt;/inserted&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_as_html</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;<br />    &lt;inserted&gt;&lt;/inserted&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_with_non_significant_ws</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root<br />  &gt;<br />    &lt;inserted<br />  /&gt;&lt;child<br />      attr="AttrValue"<br />    &gt;content&lt;/child<br />  &gt;<br />&lt;/root<br />&gt;</pre></td></tr></tbody></table></div></div></div><div class="sec" id="ch_xmlwrapp.Original_not_containing_te_1"><h5><span class="title">Original not containing text-like nodes</span></h5><p>Given the following original document (which does not contain any text-like nodes inside the root element and has not been programmatically modified):</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre><p>Then the <span class="nctnt ncbi-func">save_to_string()</span> function will produce the following outputs for the given formatting flags:</p><div class="table" id="ch_xmlwrapp.T.nc_flagsoutputxmlsave_op_3"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag(s)</th><th align="left" valign="top" rowspan="1" colspan="1">Output</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_default</span><br /><span class="nctnt ncbi-var">xml::save_op_no_empty</span><br /><span class="nctnt ncbi-var">xml::save_op_no_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_not_as_xml</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />  &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_format</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_decl</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;<br />  &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_as_html</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_with_non_significant_ws</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root<br />  &gt;&lt;child<br />      attr="AttrValue"<br />    &gt;content&lt;/child<br />  &gt;&lt;/root<br />&gt;</pre></td></tr></tbody></table></div></div></div><div class="sec" id="ch_xmlwrapp.Original_not_containing_te_2"><h5><span class="title">Original not containing text-like nodes and having programmatically inserted content</span></h5><p>Given the following original document (which does not contain any text-like nodes):</p><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre><p>And given that a node has been programmatically inserted like this:</p><pre><span class="nctnt-pre ncbi-code">xml::node &amp;             root = doc.get_root_node();<br />xml::node::iterator     insert_before;<br /><br />insert_before = root.find( "child" );<br />root.insert( insert_before, xml::node("inserted") );</span></pre><p>Then the <span class="nctnt ncbi-func">save_to_string()</span> function will produce the following outputs for the given formatting flags:</p><div class="table" id="ch_xmlwrapp.T.nc_flagsoutputxmlsave_op_4"><div class="table-scroll"><table><tbody><tr><th align="left" valign="top" rowspan="1" colspan="1">Flag(s)</th><th align="left" valign="top" rowspan="1" colspan="1">Output</th></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_default</span><br /><span class="nctnt ncbi-var">xml::save_op_no_xhtml</span><br /><span class="nctnt ncbi-var">xml::save_op_not_as_xml</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />  &lt;inserted/&gt;<br />  &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_format</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;&lt;inserted/&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_decl</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;<br />  &lt;inserted/&gt;<br />  &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_no_empty</span><br /><span class="nctnt ncbi-var">xml::save_op_xhtml</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root&gt;<br />  &lt;inserted&gt;&lt;/inserted&gt;<br />  &lt;child attr="AttrValue"&gt;content&lt;/child&gt;<br />&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_as_html</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;root&gt;&lt;inserted&gt;&lt;/inserted&gt;&lt;child attr="AttrValue"&gt;content&lt;/child&gt;&lt;/root&gt;</pre></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><span class="nctnt ncbi-var">xml::save_op_with_non_significant_ws</span><br /></td><td align="left" valign="top" rowspan="1" colspan="1"><pre>&lt;?xml version="1.0"?&gt;<br />&lt;root<br />  &gt;&lt;inserted<br />  /&gt;&lt;child<br />      attr="AttrValue"<br />    &gt;content&lt;/child<br />  &gt;&lt;/root<br />&gt;</pre></td></tr></tbody></table></div></div></div></div></div></div><div class="sec" id="ch_xmlwrapp.FAQ"><h2><span class="title">FAQ</span></h2><p><b>Q. What header files do I need to include?</b></p><p>A. You need <span class="nctnt ncbi-code">&lt;misc/xmlwrapp/xmlwrapp.hpp&gt;</span> for functionality that resides in the<span class="nctnt ncbi-code"> xml::</span> C++ namespace, and <span class="nctnt ncbi-code">&lt;misc/xmlwrapp/xsltwrapp.hpp&gt;</span> for functionality that resides in the <span class="nctnt ncbi-code">xslt::</span> C++ namespace.</p><p><b>Q. What do I need to add to my Makefile?</b></p><p>A. You need to add the following:</p><pre>LIB = xmlwrapp xncbi<br />LIBS = $(LIBXML_LIBS) $(LIBXSLT_LIBS) $(ORIG_LIBS)<br />CPPFLAGS = $(LIBXML_INCLUDE) $(LIBXSLT_INCLUDE) $(ORIG_CPPFLAGS)<br />REQUIRES = LIBXML LIBXSLT</pre><p><b>Q. I read my nicely formatted document from a file, and then I added a few nodes and saved it to a file. Why is my saved document partially unformatted - specifically, all my added nodes are glued into a single long line?</b></p><p>A. Please see the section on <a href="ch_xmlwrapp.html#ch_xmlwrapp.Formatting_of_Programmatical">Formatting of Programmatically Added Content</a>.</p><p><b>Q. Is </b><span class="nctnt ncbi-lib">libxmlwrapp</span><b> thread safe?</b></p><p>A. See the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Thread_Safety">Thread Safety</a> section for details.</p><p><b>Q. Does </b><span class="nctnt ncbi-lib">libxmlwrapp</span> <b>support XML catalogs?</b></p><p>A. Yes, to the extent that <span class="nctnt ncbi-lib">libxml2</span> supports them. All the <span class="nctnt ncbi-lib">libxml2</span> fuctionality is available, but there is no special support code for XML catalogs in the <span class="nctnt ncbi-lib">libxmlwrapp</span> library. See the <a href="ch_xmlwrapp.html#ch_xmlwrapp.Use_an_XML_Catalog">How to Use an XML Catalog</a> section for details.</p><p><b>Q. Does XmlWrapp support XPath 2.0?</b></p><p>A. XmlWrapp is based on <span class="nctnt ncbi-app">libxml2</span>, and <span class="nctnt ncbi-app">libxml2</span> does not now and may never support XPath 2.0.</p></div></div></div><div id="tkb_internal" class="col four_col last"><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" id="source-branding"><div class="iconblock clearfix ten_col"><a class="img_link icnblk_img" title="Table of Contents Page" target="mainwindow" href="toc.html"><img class="source-thumb" src="img/th-toolkit-lrg.png" alt="Cover of The NCBI C++ Toolkit Book" height="100px" width="80px" /></a><div class="icnblk_cntnt"><div class="_bk_pgbnr_cit"><div class="_bk_pgbnr_cit_ln">The NCBI C++ Toolkit Book [Internet].</div><div class="_bk_pgbnr_cit_ln">Vakatov D, editor.</div><div class="_bk_pgbnr_cit_ln">Bethesda (MD): <a href="http://www.ncbi.nlm.nih.gov/">National Center for Biotechnology Information (US)</a>; 2004-.</div></div></div></div></div><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" class="half_rhythm"><ul class="inline_list"><li><a href="toc.html">Table of Contents Page</a></li><li> | </li><li><a class="jig-ncbidialog" data-jigconfig="width:400 , modal:true" href="#citation-window">Cite this Page</a><div class="jig-ncbidialog-box" style="display:none" title="Cite this Page" id="citation-window"><div class="bk_tt">
        Vakatov D, editor. The NCBI C++ Toolkit Book [Internet]. Bethesda (MD): National Center for Biotechnology Information (US); 2004-.  21, XmlWrapp (XML parsing and handling, XSLT, XPath)
                    . 
        [Updated: November 7, 2014]
    .

                            <div class="bk_tt"><span class="bk_cite_avail">Available from: http://www.ncbi.nlm.nih.gov/toolkit/doc/book/ch_xmlwrapp</span></div></div><span class="bk_cite_avail"></span></div></li></ul></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">In this page</div></div><div class="portlet_content"><ul><li><a href="#ch_xmlwrapp.General_Information">General Information</a></li><li><a href="#ch_xmlwrapp.XmlWrapp_Classes">XmlWrapp Classes</a></li><li><a href="#ch_xmlwrapp.How_To">How To</a></li><li><a href="#ch_xmlwrapp.Warning_Collaborative_Use_of">Warning: Collaborative Use of XmlWrapp and libxml2</a></li><li><a href="#ch_xmlwrapp.Implementation_Details">Implementation Details</a></li><li><a href="#ch_xmlwrapp.FAQ">FAQ</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Search</div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â 					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr class="internal-only"><th style="text-align:left">Public</th><th style="text-align:left">Internal</th></tr><tr><td><input id="pToolkitAll" name="__symboloc" type="radio" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td><td class="internal-only"><input id="iToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="iToolkitAll" title="Search in the C/C++ source code,  this Book, and Wiki">All</label></td></tr><tr><td><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td><td class="internal-only"><input id="iLXR" name="__symboloc" type="radio" /><label for="iLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td><td class="internal-only"><input id="iLib" name="__symboloc" type="radio" /><label for="iLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Source Browsers</div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> LXR: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lxr/ident" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Doxygen: </span><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a><span class="bkp_prtlt_txt"> / </span><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/doxyhtml" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">SVN Source Repository</div></div><div class="portlet_content"><ul><li class="internal-only"><span class="bkp_prtlt_txt"> Documentation: </span><a href="ch_getcode_svn.html#ch_getcode_svn.code_retrieval">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="ch_getcode_svn.html#ch_getcode_svn.external">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (dev): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a><span class="bkp_prtlt_txt"> / </span><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">public</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (extra): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/trunk/internal/c++" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li><li class="internal-only"><span class="bkp_prtlt_txt"> Web (prod): </span><a href="https://svn.ncbi.nlm.nih.gov/viewvc/toolkit/production/components" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">in-house</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Resources</div></div><div class="portlet_content"><ul><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/wiki-private/CxxToolkit" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Wiki</a></li><li class="internal-only"><a href="https://jira.ncbi.nlm.nih.gov/browse/CXX" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">JIRA</a></li><li class="internal-only"><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/STAT/test_stat/test_stat_ext.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="View results of testsuite runs on the automatic C++ Toolkit builds">Testsuite</span></a></li><li><a href="http://intranet/ieb/ToolBox/GRID/dashboard/">GRID Dashboard</a></li><li><a href="http://intranet.ncbi.nlm.nih.gov/ieb/ToolBox/SC/index.html">Stable Components</a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download the Toolkit</a></li><li><a href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:cpp-doc@ncbi.nlm.nih.gov" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div><div id="tkb_public" class="col four_col last"><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" id="source-branding"><div class="iconblock clearfix ten_col"><a class="img_link icnblk_img" title="Table of Contents Page" target="mainwindow" href="toc.html"><img class="source-thumb" src="img/th-toolkit-lrg.png" alt="Cover of The NCBI C++ Toolkit Book" height="100px" width="80px" /></a><div class="icnblk_cntnt"><div class="_bk_pgbnr_cit"><div class="_bk_pgbnr_cit_ln">The NCBI C++ Toolkit Book [Internet].</div><div class="_bk_pgbnr_cit_ln">Vakatov D, editor.</div><div class="_bk_pgbnr_cit_ln">Bethesda (MD): <a href="http://www.ncbi.nlm.nih.gov/">National Center for Biotechnology Information (US)</a>; 2004-.</div></div></div></div></div><div xmlns:str="http://exslt.org/strings" xmlns:c="http://exslt.org/common" class="half_rhythm"><ul class="inline_list"><li><a href="toc.html">Table of Contents Page</a></li><li> | </li><li><a class="jig-ncbidialog" data-jigconfig="width:400 , modal:true" href="#citation-window">Cite this Page</a><div class="jig-ncbidialog-box" style="display:none" title="Cite this Page" id="citation-window"><div class="bk_tt">
        Vakatov D, editor. The NCBI C++ Toolkit Book [Internet]. Bethesda (MD): National Center for Biotechnology Information (US); 2004-.  21, XmlWrapp (XML parsing and handling, XSLT, XPath)
                    . 
        [Updated: November 7, 2014]
    .

                            <div class="bk_tt"><span class="bk_cite_avail">Available from: http://www.ncbi.nlm.nih.gov/toolkit/doc/book/ch_xmlwrapp</span></div></div><span class="bk_cite_avail"></span></div></li></ul></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">In this page</div></div><div class="portlet_content"><ul><li><a href="#ch_xmlwrapp.General_Information">General Information</a></li><li><a href="#ch_xmlwrapp.XmlWrapp_Classes">XmlWrapp Classes</a></li><li><a href="#ch_xmlwrapp.How_To">How To</a></li><li><a href="#ch_xmlwrapp.Warning_Collaborative_Use_of">Warning: Collaborative Use of XmlWrapp and libxml2</a></li><li><a href="#ch_xmlwrapp.Implementation_Details">Implementation Details</a></li><li><a href="#ch_xmlwrapp.FAQ">FAQ</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Search</div></div><div class="portlet_content"><form name="frmSymbolSearch" onsubmit="return SymbolSearch('toolkit')" action="/" id="frmSymbolSearch"><table><tbody><tr align="center" valign="middle"><td colspan="2" nowrap="nowrap"><input id="search_box" name="__symbol" style="vertical-align:                                        middle; line-height:normal " onkeypress="SymbolSearchKeyPress('toolkit',event)" type="text" />Â Â 					<label for="search_box" class="offscreen_noflow">Search term</label><button type="submit" value="Search" style="vertical-align:                                        middle; line-height:normal;" onclick="javasrcipt:SymbolSearch('toolkit');">Search</button></td></tr><tr><td colspan="2"><input id="pToolkitAll" name="__symboloc" type="radio" checked="checked" /><label for="pToolkitAll" title="Search in the C/C++ source code and in this Book">All</label></td></tr><tr><td colspan="2"><input id="pLXR" name="__symboloc" type="radio" /><label for="pLXR" title="Search the symbol in the source code using LINUX Cross-Reference browser">LXR</label></td></tr><tr><td colspan="2"><input id="pLib" name="__symboloc" type="radio" /><label for="pLib" title="Locate the Toolkit library(es) where the symbol is defined">Library</label></td></tr></tbody></table></form></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Source Browsers</div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">LXR</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident">Doxygen</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">SVN Source Repository</div></div><div class="portlet_content"><ul><li class="external-only"><a href="ch_getcode_svn.html#ch_getcode_svn.external">Documentation</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Web (dev)</a></li></ul></div></div><div class="portlet"><div class="portlet_head"><div class="portlet_title">Resources</div></div><div class="portlet_content"><ul><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lib_search/libsearch.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Search Tool</a></li><li class="external-only"><a href="http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/depgraphs/dglistdeps.cgi" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri">Library Dependencies Tool</a></li><li><a href="release_notes.html">Release Notes</a></li><li><a href="ch_getcode_svn.html#ch_getcode_svn.ftp_download">Download the Toolkit</a></li><li><a href="http://www.ncbi.nlm.nih.gov/toolkit/doc/book/pdf/TOC.pdf">PDF of the book</a></li><li><a href="ch_style.html">Coding Style</a></li><li><a href="ch_faq.html#ch_faq.mailing_lists">Mailing Lists</a></li><li><a href="mailto:cpp-doc@ncbi.nlm.nih.gov" ref="pagearea=source-application&amp;targetsite=external&amp;targetcat=link&amp;targettype=uri"><span title="Contact C++ Toolkit group">Help and Support</span></a></li></ul></div></div></div></div></div></div></body></html>
